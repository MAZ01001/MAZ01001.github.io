<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BigIntType-calculator</title>
    <style>
        ::-webkit-scrollbar{width: 0.9em;height: 0.9em;}
        ::-webkit-scrollbar-thumb:window-inactive{border-color: #040F !important;}
        ::-webkit-scrollbar-thumb:vertical{
            background-color: #0000;
            border-right: .3em solid #080F;
            border-radius: 0;
        }
        ::-webkit-scrollbar-thumb:vertical:hover{
            background-color: #0F0F;
            border: none;
            border-top-left-radius: 1em;
            border-bottom-left-radius: 1em;
        }
        ::-webkit-scrollbar-thumb:horizontal{
            background-color: #0000;
            border-bottom: .3em solid #080F;
            border-radius: 0;
        }
        ::-webkit-scrollbar-thumb:horizontal:hover{
            background-color: #0F0F;
            border: none;
            border-top-left-radius: 1em;
            border-top-right-radius: 1em;
        }
        ::-webkit-scrollbar-track{display: none;background-color: #0000;}
        ::-webkit-scrollbar-track-piece{display: none;background-color: #0000;}
        ::-webkit-scrollbar-corner{display: none;background-color: #0000;}
        body{
            background-color: #000;
            color: #0f0;
            padding: 0;
            margin: 0;
            overflow: visible;
            font-family: 'Times New Roman', Times, serif;
            font-size: large;
        }
        *{user-select: none;}
        div#box{
            position: absolute;
            top: 50%;left: 50%;
            transform:translate(-50%, -50%);
            width: max-content;
            height: max-content;
            padding: 0  .5em 1em .5em;
            max-width: calc(100vw - 1em);
            max-height: calc(100vh - 1em);
            overflow: overlay;
            background-color:#222;
            border-radius: 1em;
            text-align: center;
        }
        div#box>h1,div#box label[for="base_chooser"]{user-select: text;}
        div#border{
            display: grid;
            grid-template-columns: 18.2rem auto calc(50% - 17rem) 17rem;
            min-width: 40em;
            padding: 1em;
            width: max-content;
            border-spacing: 0;
        }
        div#border>div[data-content]{
            vertical-align: middle;
            border: .2em inset #444;
            padding: .3em .5em;
        }
        div#border>div[data-content]:hover{border-color: #a70;}
        div#border>div[data-content="base_chooser"]{grid-area: 1/1/2/2;}        div#border>div[data-content="memory_size"]{grid-area: 1/4/2/5;}
        div#border>div[data-content="number_a"]{grid-area: 2/1/3/3;}            div#border>div[data-content="number_b"]{grid-area: 2/3/3/5;}
        div#border>div[data-content="function-buttons"]{grid-area: 3/1/4/3;}    div#border>div[data-content="saved_numbers"]{grid-area: 3/3/6/5;}
        div#border>div[data-content="Arandom"]{grid-area: 4/1/5/3;}
        div#border>div[data-content="Amap"]{grid-area: 5/1/6/3;}
        div#border>div[data-content="error_output"]{grid-area: 6/1/7/5;}
        div.button{display: inline;white-space: nowrap;}
        div[data-content="function-buttons"]{
            display: grid;
            grid-auto-columns: 6;
            min-width: min-content;
            gap: .2em .1em;
        }
        #AaddB{grid-area: 1/1/2/2;}                     #AsubB{grid-area: 1/2/2/3;}     #AmulB{grid-area: 1/3/2/5;}     #ApowB{grid-area: 1/5/2/6;}     #switchAB{grid-area: 1/6/2/7;}
        div[data-content="AdivB"]{grid-area: 2/1/3/4;}  div[data-content="AmodB"]{grid-area: 2/4/3/7;}
        #bitAls{grid-area: 3/1/4/3;}                    #bitAls_x{grid-area: 3/3/4/6;}  #gcdAB{grid-area: 3/6/5/7;}
        #bitArs{grid-area: 4/1/5/3;}                    #bitArs_x{grid-area: 4/3/5/6;}
        #bitnoA{grid-area: 5/1/6/2;}                    #bitnoB{grid-area: 5/2/6/3;}    #bitAanB{grid-area: 5/3/6/5;}   #bitAorB{grid-area: 5/5/6/6;}   #bitAxoB{grid-area: 5/6/6/7;}
        #AtB{grid-area: 6/1/7/7;}
        div[data-content="Arandom"]{
            display: grid;
            grid-template-columns: auto auto 50%;
            min-width: min-content;
            gap: .2em .1em;
            text-align: left;
        }
        #Arandom{grid-area: 1/1/2/2;}
        label[for="Arandommin"]{grid-area: 2/1/3/3;}    label[for="Arandommax"]{grid-area: 2/3/3/4;}
        #Arandommin{grid-area: 3/1/4/3;}                #Arandommax{grid-area: 3/3/4/4;}
        div[data-content="Amap"]{
            display: grid;
            grid-template-columns: auto auto 50%;
            min-width: min-content;
            gap: .2em .1em;
            text-align: left;
        }
        #Amap{grid-area: 1/1/2/2;}                      div[data-content="Amaplimit"]{grid-area: 1/3/2/4;}
        label[for="Amapmin1"]{grid-area: 2/1/3/3;}      label[for="Amapmax1"]{grid-area: 2/3/3/4;}
        #Amapmin1{grid-area: 3/1/4/3;}                  #Amapmax1{grid-area: 3/3/4/4;}
        label[for="Amapmin2"]{grid-area: 4/1/5/3;}      label[for="Amapmax2"]{grid-area: 4/3/5/4;}
        #Amapmin2{grid-area: 5/1/6/3;}                  #Amapmax2{grid-area: 5/3/6/4;}
        div#border>div[data-content="base_chooser"],
        div#border>div[data-content="number_a"],
        div#border>div[data-content="number_b"]{text-align: left;}
        .number{
            display: block;
            width: calc(100% - 0.5em);
            min-height: 1rem;
            max-height: 10rem;
            height: fit-content;
            overflow-y: overlay;
            font-family: 'consolas', monospace;
            user-select: text;
            resize: vertical;
        }
        .number:invalid{color: #f00;}
        #Amaplimit{
            position: fixed;
            left: -10rem;
            opacity: 0;
        }
        label[for="Amaplimit"]{
            border: 2px outset #040;
            outline: none !important;
            padding: .1em .5em;
            font-size: smaller;
        }
        #Amaplimit:not(:checked)+label[for="Amaplimit"]{background-color: #000;}
        #Amaplimit:checked+label[for="Amaplimit"]{background-color: #040;}
        select,button,.number,#error_output{
            background-color: #000;
            color: #0f0;
            border-radius: 0;
            border-color: #040;
            border-style: outset;
            outline: none !important;
        }
        select:hover,button:hover,.number:hover,#error_output:hover,label[for="Amaplimit"]:hover{border-color: #080;}
        select:focus,button:focus,.number:focus,#error_output:focus,#Amaplimit:focus+label[for="Amaplimit"]{border-color: #0a0;}
        select:active,button:active,.number:active,#error_output:active,label[for="Amaplimit"]:active{border-color: #0f0 !important;}
        #AtB{
            background-color: #000;
            color: #0f0;
            display: inline-block;
            white-space: nowrap;
            font-family: 'consolas', monospace;
            font-size: 1rem;
            padding: .1rem .5rem;
        }
        #error_output{
            color: #f00 !important;
            width: calc(100% - 0.5em);
            min-height: 1rem;
            max-height: 10rem;
            font-weight: bold;
            font-family: 'consolas', monospace;
            user-select: text;
            resize: none;
        }
        div#loader{
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            backdrop-filter: blur(6px);
            z-index: 9999;
            background-image: radial-gradient(transparent,transparent,black,black);
        }
        div#loader>div{
            font-size: 2em;
            font-family: serif;
            position: absolute;
            transform: translate(-50%,-50%);
            top: 50%;
            left: 50%;
            width: 100%;
            text-align: center;
        }
    </style>
    <script data-info="2022-03-28 from https://github.com/MAZ01001/Math-Js/blob/main/BigIntType.js">
        class BigIntType{
            //~ property/method names starting with '#' are private - see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields for details
            /*
                max number with 500 base 256 digits is
                256**500-1 = 13 182 040 934 309 431 001 038 897 942 365 913 631 840 191 610 932 727
                    690 928 034 502 417 569 281 128 344 551 079 752 123 172 122 033 140 940 756 480
                    716 823 038 446 817 694 240 581 281 731 062 452 512 184 038 544 674 444 386 888
                    956 328 970 642 771 993 930 036 586 552 924 249 514 488 832 183 389 415 832 375
                    620 009 284 922 608 946 111 038 578 754 077 913 265 440 918 583 125 586 050 431
                    647 284 603 636 490 823 850 007 826 811 672 468 900 210 689 104 488 089 485 347
                    192 152 708 820 119 765 006 125 944 858 397 761 874 669 301 278 745 233 504 796
                    586 994 514 054 435 217 053 803 732 703 240 283 400 815 926 169 348 364 799 472
                    716 094 576 894 007 243 168 662 568 886 603 065 832 486 830 606 125 017 643 356
                    469 732 407 252 874 567 217 733 694 824 236 675 323 341 755 681 839 221 954 693
                    820 456 072 020 253 884 371 226 826 844 858 636 194 212 875 139 566 587 445 390
                    068 014 747 975 813 971 748 114 770 439 248 826 688 667 129 237 954 128 555 841
                    874 460 665 729 630 492 658 600 179 338 272 579 110 020 881 228 767 361 200 603
                    478 973 120 168 893 997 574 353 727 653 998 969 223 092 798 255 701 666 067 972
                    698 906 236 921 628 764 772 837 915 526 086 464 389 161 570 534 616 956 703 744
                    840 502 975 279 094 087 587 298 968 423 516 531 626 090 898 389 351 449 020 056
                    851 221 079 048 966 718 878 943 309 232 071 978 575 639 877 208 621 237 040 940
                    126 912 767 610 658 141 079 378 758 043 403 611 425 454 744 180 577 150 855 204
                    937 163 460 902 512 732 551 260 539 639 221 457 005 977 247 266 676 344 018 155
                    647 509 515 396 711 351 487 546 062 479 444 592 779 055 555 421 362 722 504 575
                    706 910 949 375 in base 10 which is 1205 digits (2.41 times longer)
            */
            //~ for potentially larger numbers Uint16Array could be used ('cause 2**16*2**16 is still a save integer is js so save to compute)
            //~ but it is the same size in memory just potentially a longer number 'cause the index can go higher (a digit-array in base 65536 is 2x shorter than in base 256)
            //~ but with (2**53-1) digits (MAX_SAFE_INTEGER) and 1Byte (base 256) per digit - it is large enough (usually not more than 2GB can be allocated anyways...)
            /**@type {number} - maximum possible length of a number _(excluding sign)_ - originally `500` = 0.5KB in RAM */
            static #MAX_SIZE=500;
            /**@returns {number} _current_ maximum possible length of a number _(excluding sign)_ */
            static get MAX_SIZE(){return BigIntType.#MAX_SIZE;}
            /**@throws {RangeError} - if setting this to a number that is not an integer in range `[1-1048576]` - _( `1048576` = 1MiB in RAM )_ */
            static set MAX_SIZE(n){
                //~ technically, max is 9007199254740991 (Number.MAX_SAFE_INTEGER) but with 1 Byte each entry that's almost 8PiB ! for ONE number
                //~ and chrome browser will only create typed arrays up to 2GiB
                if(!Number.isInteger(n)||n<1||n>1048576){throw new RangeError("[MAX_SIZE] must be an integer in range [1-1048576]");}
                return BigIntType.#MAX_SIZE=n;
            }
            /**@type {Readonly<{0:RegExp;2:RegExp;4:RegExp;8:RegExp;10:RegExp;16:RegExp;36:RegExp;256:RegExp;}>} - regular expressions for matching strings in specific base with optional sign, minimum one digit and no leading zeros */
            static #REGEXP_STRING=Object.freeze({
                0:/^([+-]?)(\u2800|[\u2801-\u28FF][\u2800-\u28FF]*)$/, //~ base 256 in braille-patterns
                2:/^([+-]?)(?:0b)?(0|1[01]*)$/i,
                4:/^([+-]?)(0|[1-3][0-3]*)$/,
                8:/^([+-]?)(?:0o)?(0|[1-7][0-7]*)$/i,
                10:/^([+-]?)(0|[1-9][0-9]*)$/,
                16:/^([+-]?)(?:0x)?(0|[1-9A-F][0-9A-F]*)$/i,
                36:/^([+-]?)(0|[1-9A-Z][0-9A-Z]*)$/i,
                256:/^([+-]?)(0|(?:[1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(?:\,(?:[1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))*)$/
            });
            /**@type {boolean} - sign of the number - `true` = positive */
            #sign=true;
            /**@returns {boolean} sign of the number - `true` = positive */
            get sign(){return this.#sign;}
            /**@type {Uint8Array} - the number as unsigned 8bit integer array (base 256) - index 0 is the 0st-digit of the number */
            #digits=new Uint8Array(1);
            /**
             * @returns {Uint8Array} a copy of the digits as an unsigned 8bit integer array (base 256) - index 0 is the 0st-digit of the number
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            get digits(){return this.#digits.slice();}
            /**@returns {number} number of digits (base 256)*/
            get length(){return this.#digits.length;}
            /**
             * @returns {BigIntType} biggest possible number according to `MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static get MAX_VALUE(){return new BigIntType(new Uint8Array(BigIntType.MAX_SIZE).fill(255),"256");}
            /**
             * @returns {BigIntType} "Hello There" in Braille - see `this.toString("braille")`
             * @throws {RangeError} - if current `MAX_SIZE` is to small - requires 22B
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static get HelloThere(){
                if(BigIntType.MAX_SIZE<22){throw new RangeError("[HelloThere] MAX_SIZE is to small");}
                return new BigIntType(new Uint8Array([65,239,133,95,65,239,71,103,1,185,0,0,71,207,64,199,64,199,65,239,71,103]),"256");
            }
            /**
             * @returns {BigIntType} Infinity - `2**1024` ~ 1.79e308
             * @throws {RangeError} - if current `MAX_SIZE` is to small - requires 129B
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static get Infinity(){
                if(BigIntType.MAX_SIZE<129){throw new RangeError("[Infinity] MAX_SIZE is to small");}
                return new BigIntType(new Uint8Array([...new Uint8Array(128),1]),"256");
            }
            /**
             * @returns {BigIntType} `0`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static get Zero(){return new BigIntType(new Uint8Array([0]),"256");}
            /**
             * @returns {BigIntType} `1`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static get One(){return new BigIntType(new Uint8Array([1]),"256");}
            /**
             * @returns {BigIntType} `2`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static get Two(){return new BigIntType(new Uint8Array([2]),"256");}
            /**
             * __constructs a BigIntType number__
             * @param {string|boolean[]|Uint8Array} num - an integer - _default `'1'`_
             * + + ( in arrays the number is unsigned and index 0 = 0th-place-digit for example: `"1230"` → `[0,3,2,1]` )
             * + + ( if `num` is an Uint8Array and `base` 256 then the original Uint8Array will be used )
             * + `base` 2   → as string or Uint8Array `0` and `1` or as bool array `true` and `false`
             * + `base` 4   → as string or Uint8Array `0` to `3`
             * + `base` 8   → as string or Uint8Array `0` to `7`
             * + `base` 10  → as string or Uint8Array `0` to `9`
             * + `base` 16  → as string `0` to `9` and `A` to `F` or as Uint8Array `0` to `16`
             * + `base` 32  → as string `0` to `9` and `A` to `Z` or as Uint8Array `0` to `36`
             * + `base` 256 → as string `⠀` to `⣿` (braille-patterns `0x2800` to `0x28FF`), `0` to `255` (comma-separated list) or as Uint8Array `0` to `256`
             * @param {string|number} base - base of `num` as a number or string (case insensitive) - _default `'d'`_
             * + base 2 can be `'b'`, `"bin"`, `"bit"`, `"binary"`, `'2'` or `2`
             * + base 4 can be `'c'`, `"crumb"`, `'q'`, `"quaternary"`, `'4'` or `4`
             * + base 8 can be `'o'`, `"oct"`, `"octal"`, `'8'` or `8`
             * + base 10 can be `'d'`, `"dec"`, `"decimal"`, `"10"` or `10`
             * + base 16 can be `'x'`, `'h'`, `"hex"`, `"hexadecimal"`, `'n'`, `"nibble"`, `"16"` or `16`
             * + base 36 can be `'t'`, `"text"`, `"bin-text"`, `"36"` or `36`
             * + base 256 can be `"braille"`, `"byte"`, `"256"` or `256` (`"braille"` must be a unicode braille-pattern string)
             * @throws {SyntaxError} - if `base` is not an available option
             * @throws {SyntaxError} - if `base` is `"braille"` and `num` is not a string
             * @throws {SyntaxError} - if `num` does not have the correct format for this `base`
             * @throws {RangeError} - if `num` exceedes `MAX_SIZE` (after conversion in base 256)
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            constructor(num='1',base='d'){
                this.#sign=true;
                if(!(num instanceof Uint8Array)){num=String(num);}
                if(num==='0'||num==='\u2800'||(num.length===1&&(num[0]===0||num[0]===false))){this.#digits=new Uint8Array(1);return;}
                if(num==='1'||num==='\u2801'||(num.length===1&&(num[0]===1||num[0]===true))){this.#digits=new Uint8Array([1]);return;}
                switch(String(base).toLowerCase()){
                    /*
                        all your base are belong to us
                        3   ternary trinary             [0-2]
                        5   quinary pental              [0-4]
                        6   senary heximal seximal      [0-5]
                        12  duodecimal dozenal uncial   [0-9,A-B]
                        20  vigesimal                   [0-9,A-J]
                        60  sexagesimal sexagenary      [?]
                    */
                    case'b':case"bin":case"bit":case"binary":case'2':base=2;break;
                    case'c':case"crumb":
                    case'q':case"quaternary":case'4':base=4;break;
                    case'o':case"oct":case"octal":case'8':base=8;break;
                    case'd':case"dec":case"decimal":case"10":base=10;break;
                    case'n':case"nibble":
                    case'x':case'h':case"hex":case"hexadecimal":case"16":base=16;break;
                    case't':case"text":case"bin-text":case"36":base=36;break;
                    case"byte":case"256":base=256;break;
                    case"braille":base=0;break;
                    default:throw new SyntaxError("[new BigIntType] base is not an available option");
                }
                if(base===2&&Array.isArray(num)){
                    if(num.every(v=>typeof(v)==="boolean")){num=new Uint8Array(num);}
                    else{throw new SyntaxError("[new BigIntType] num (array) has incorrect values for base 2");}
                }
                if(base===0&&num instanceof Uint8Array){throw new SyntaxError("[new BigIntType] base \"braille\" requires num to be a string");}
                /**@type {boolean} - if `num` is a string this will be the sign of the number (after the conversion) */
                let _sign=true;
                if(typeof num==="string"){
                    /**@type {RegExpMatchArray|null} - sign and number from string or `null` if no match*/
                    let _match=num.match(BigIntType.#REGEXP_STRING[base]);
                    if(!_match){throw new SyntaxError(`[new BigIntType] num (string) does not have the correct format for base ${base===0?'256 (braille)':base}`);}
                    _sign=_match[1]!=='-';
                    switch(base){
                        case 2:case 4:case 8:case 10:num=new Uint8Array([..._match[2]].reverse());break;
                        case 16:num=new Uint8Array([..._match[2]].map(v=>Number.parseInt(v,16)).reverse());break;
                        case 36:num=new Uint8Array([..._match[2]].map(v=>Number.parseInt(v,36)).reverse());break;
                        case 256:num=new Uint8Array(_match[2].split(',').reverse());break;
                        case 0:num=new Uint8Array([..._match[2]].map(v=>v.charCodeAt(0)-10240).reverse());base=256;break;
                    }
                }
                if(base!==256){if(num.some(v=>v>=base)){throw new SyntaxError(`[new BigIntType] num (Uint8Array) has incorrect values for base ${base}`);}}
                switch(base){
                    case 2:
                        this.#digits=new Uint8Array(Math.ceil(num.length/8));
                        for(let i=0;i<this.length;i++){
                            this.#digits[i]=num[i*8]+
                                ((num[i*8+1]||0)<<1)+
                                ((num[i*8+2]||0)<<2)+
                                ((num[i*8+3]||0)<<3)+
                                ((num[i*8+4]||0)<<4)+
                                ((num[i*8+5]||0)<<5)+
                                ((num[i*8+6]||0)<<6)+
                                ((num[i*8+7]||0)<<7);
                        }
                        break;
                    case 4:
                        this.#digits=new Uint8Array(Math.ceil(num.length/4));
                        for(let i=0;i<this.length;i++){
                            this.#digits[i]=num[i*4]+
                                ((num[i*4+1]||0)*4)+
                                ((num[i*4+2]||0)*16)+ //~ 4**2
                                ((num[i*4+3]||0)*64); //~ 4**3
                        }
                        break;
                    case 8:
                        /**@type {string[]} - digits in base 8*/
                        let b8=Array.from(num,String),
                            /**@type {string[]} - digits for base 256*/
                            __b256=[];
                        for(;b8.length>3||(b8.length===3&&Number(b8[2])>=4);){//~ b8 >=256 (400_b8)
                            __b256.push('0');
                            for(let i=0;i<8;i++){
                                if(Number(b8[0])&1){__b256[__b256.length-1]=String(Number(__b256[__b256.length-1])+(1<<i));}
                                if(b8.length===1&&b8[0]==='0');//~ b8 /2
                                else if(b8.length===1&&b8[0]==='1'){b8[0]='0';}
                                else{
                                    b8[0]=String(Number(b8[0])>>>1);
                                    for(let i=1;i<b8.length;i++){
                                        if(Number(b8[i])&1){b8[i-1]=String(Number(b8[i-1])+4);}
                                        b8[i]=String(Number(b8[i])>>>1);
                                    }
                                    if(b8[b8.length-1]==='0'){b8.splice(-1,1);}
                                }
                            }
                        }
                        __b256.push(String(Number.parseInt(b8.reverse().join(''),8)));
                        this.#digits=new Uint8Array(__b256);
                        break;
                    case 10:
                        /**@type {string[]} - digits in base 10*/
                        let b10=Array.from(num,String),
                            /**@type {string[]} - digits for base 256*/
                            b256=[];
                        for(;b10.length>3||(b10.length===3&&(Number(b10[2])>2||(Number(b10[2])===2&&(Number(b10[1])>5||(Number(b10[1])===5&&(Number(b10[0])>=6))))));){//~ b10 >=256
                            b256.push('0');
                            for(let i=0;i<8;i++){
                                if(Number(b10[0])&1){b256[b256.length-1]=String(Number(b256[b256.length-1])+(1<<i));}
                                if(b10.length===1&&b10[0]==='0');//~ b10 /2
                                else if(b10.length===1&&b10[0]==='1'){b10[0]='0';}
                                else{
                                    b10[0]=String(Number(b10[0])>>>1);
                                    for(let i=1;i<b10.length;i++){
                                        if(Number(b10[i])&1){b10[i-1]=String(Number(b10[i-1])+5);}
                                        b10[i]=String(Number(b10[i])>>>1);
                                    }
                                    if(b10[b10.length-1]==='0'){b10.splice(-1,1);}
                                }
                            }
                        }
                        b256.push(b10.reverse().join(''));
                        this.#digits=new Uint8Array(b256);
                        break;
                    case 16:
                        this.#digits=new Uint8Array(Math.ceil(num.length/2));
                        for(let i=0;i<this.length;i++){
                            this.#digits[i]=num[i*2]+
                            ((num[i*2+1]||0)*16);
                        }
                        break;
                    case 36:
                        /**@type {string[]} - digits in base 36*/
                        let b36=Array.from(num,String),
                            /**@type {string[]} - digits for base 256*/
                            _b256=[];
                        for(;b36.length>2||(b36.length===2&&(Number(b36[1])>7||(b36[1]==='7'&&(Number(b36[0])>=4))));){//~ b36 >=256 (74_b36)
                            _b256.push('0');
                            for(let i=0;i<8;i++){
                                if(Number(b36[0])&1){_b256[_b256.length-1]=String(Number(_b256[_b256.length-1])+(1<<i));}
                                if(b36.length===1&&b36[0]==='0');//~ b36 /2
                                else if(b36.length===1&&b36[0]==='1'){b36[0]='0';}
                                else{
                                    b36[0]=String(Number(b36[0])>>>1);
                                    for(let i=1;i<b36.length;i++){
                                        if(Number(b36[i]||0)&1){b36[i-1]=String(Number(b36[i-1])+18);}
                                        b36[i]=String(Number(b36[i]||0)>>>1);
                                    }
                                    if(b36[b36.length-1]==='0'){b36.splice(-1,1);}
                                }
                            }
                        }
                        _b256.push(String(Number(b36.reverse().join(''))));
                        this.#digits=new Uint8Array(_b256);
                        break;
                    case 256:this.#digits=num;break;
                }
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                this.#sign=_sign;
                if(this.length>BigIntType.MAX_SIZE){throw new RangeError(`[new BigIntType] new number is longer than [MAX_SIZE]`);}
            }
            /**
             * __convert `this` number to string__
             * @param {string|number} base - base of number/digit string - case insensitive - _default `'x`_
             * + base 2 can be      `'b'`, `"bin"`, `"bit"`, `"binary"`, `'2'` or `2`                           → `'0'`-`'1'` (prefix `0b`)
             * + base 4 can be      `'c'`, `"crumb"`, `'q'`, `"quaternary"`, `'4'` or `4`                       → `'0'`-`'3'`
             * + base 8 can be      `'o'`, `"oct"`, `"octal"`, `'8'` or `8`                                     → `'0'`-`'7'` (prefix `0o`)
             * + base 10 can be     `'d'`, `"dec"`, `"decimal"`, `"10"` or `10`                                 → `'0'`-`'9'`
             * + base 16 can be     `'x'`, `'h'`, `"hex"`, `"hexadecimal"`, `'n'`, `"nibble"`, `"16"` or `16`   → `'0'`-`'9'` & `'A'`-`'F'` (prefix `0x`)
             * + base 36 can be     `'t'`, `"text"`, `"bin-text"`, `"36"` or `36`                               → `'0'`-`'9'` & `'A'`-`'Z'`
             * + base 256 can be    `"byte"`, `"256"` or `256`                                                  → `"0"`-`"255"` (comma-separated list)
             * + or                 `"braille"`,                                                                → `'⠀'`-`'⣿'` (Unicode Braille Pattern) `0x2800`-`0x28FF`
             * @returns {string} `this` number as string (in base `base`)
             * @throws {SyntaxError} if `base` is not an available option
             */
            toString(base=16){
                let out="";
                switch(String(base).toLowerCase()){
                    case'b':case"bin":case"bit":case"binary":case'2':out="0b"+this.#digits[this.length-1].toString(2);for(let i=this.length-2;i>=0;i--){out+=this.#digits[i].toString(2).padStart(8,'0');}break;
                    case'c':case"crumb":case'q':case"quaternary":case'4':out=this.#digits[this.length-1].toString(4);for(let i=this.length-2;i>=0;i--){out+=this.#digits[i].toString(4).padStart(4,'0');}break;
                    case'o':case"oct":case"octal":case'8':
                        /**@type {string[]} - digit-array base 8 */
                        let b8=['0'];
                        for(let i=this.length-1;i>=0;i--){
                            for(let j=7;j>=0;j--){
                                if(b8.length>1||b8[0]!=='0'){//~ b8 *=2
                                    for(let i=0,o=false,z=0;i<b8.length||o;i++){
                                        if(b8[i]==='0'&&!o){continue;}
                                        z=(Number(b8[i]||0)<<1)+(o?1:0);
                                        if(z>=8){
                                            b8[i]=String(z-8);
                                            o=true;
                                        }else{
                                            b8[i]=String(z);
                                            o=false;
                                        }
                                    }
                                }
                                if(this.#digits[i]&(1<<j)){b8[0]=String(Number(b8[0])|1);}
                            }
                        }
                        b8.push("0o");
                        out=b8.reverse().join('');
                        break;
                    case'd':case"dec":case"decimal":case"10":
                        /**@type {string[]} - digit-array base 10 */
                        let b10=['0'];
                        for(let i=this.length-1;i>=0;i--){
                            for(let j=7;j>=0;j--){
                                if(b10.length>1||b10[0]!=='0'){//~ b10 *=2
                                    for(let i=0,o=false,z=0;i<b10.length||o;i++){
                                        if(b10[i]==='0'&&!o){continue;}
                                        z=(Number(b10[i]||0)<<1)+(o?1:0);
                                        if(z>=10){
                                            b10[i]=String(z-10);
                                            o=true;
                                        }else{
                                            b10[i]=String(z);
                                            o=false;
                                        }
                                    }
                                }
                                if(this.#digits[i]&(1<<j)){b10[0]=String(Number(b10[0])|1);}
                            }
                        }
                        out=b10.reverse().join('');
                        break;
                    case'n':case"nibble":case'x':case'h':case"hex":case"hexadecimal":case"16":out="0x"+this.#digits[this.length-1].toString(16).toUpperCase();for(let i=this.length-2;i>=0;i--){out+=this.#digits[i].toString(16).toUpperCase().padStart(2,'0');}break;
                    case't':case"text":case"bin-text":case"36":
                        /**@type {string[]} - digit-array base 36 */
                        let b36=['0'];
                        for(let i=this.length-1;i>=0;i--){
                            for(let j=7;j>=0;j--){
                                if(b36.length>1||b36[0]!=='0'){//~ b36 *=2
                                    for(let i=0,o=false,z=0;i<b36.length||o;i++){
                                        if(b36[i]==='0'&&!o){continue;}
                                        z=(Number.parseInt(b36[i]||0,36)<<1)+(o?1:0);
                                        if(z>=36){
                                            b36[i]=(z-36).toString(36).toUpperCase();
                                            o=true;
                                        }else{
                                            b36[i]=z.toString(36).toUpperCase();
                                            o=false;
                                        }
                                    }
                                }
                                if(this.#digits[i]&(1<<j)){b36[0]=(Number.parseInt(b36[0],36)|1).toString(36).toUpperCase();}
                            }
                        }
                        out=b36.reverse().join('');
                        break;
                    case"braille":for(let i=this.length-1;i>=0;i--){out+=String.fromCharCode(10240+this.#digits[i]);}break;
                    case"byte":case"256":for(let i=this.length-1;i>=0;i--){out+=String(this.#digits[i])+(i!==0?',':'');}break;
                    default:throw new SyntaxError("[toString] base is not an available option");
                }
                if(!this.#sign){out='-'+out;}
                return out;
            }
            /**
             * __logs number as string (in base `base`) to console and returns itself (`this`)__
             * @param {string|number} base - base of number/digit string - case insensitive - _default `'x`_
             * + base 2 can be      `'b'`, `"bin"`, `"bit"`, `"binary"`, `'2'` or `2`                           → `'0'`-`'1'` (prefix `0b`)
             * + base 4 can be      `'c'`, `"crumb"`, `'q'`, `"quaternary"`, `'4'` or `4`                       → `'0'`-`'3'`
             * + base 8 can be      `'o'`, `"oct"`, `"octal"`, `'8'` or `8`                                     → `'0'`-`'7'` (prefix `0o`)
             * + base 10 can be     `'d'`, `"dec"`, `"decimal"`, `"10"` or `10`                                 → `'0'`-`'9'`
             * + base 16 can be     `'x'`, `'h'`, `"hex"`, `"hexadecimal"`, `'n'`, `"nibble"`, `"16"` or `16`   → `'0'`-`'9'` & `'A'`-`'F'` (prefix `0x`)
             * + base 36 can be     `'t'`, `"text"`, `"bin-text"`, `"36"` or `36`                               → `'0'`-`'9'` & `'A'`-`'Z'`
             * + base 256 can be    `"byte"`, `"256"` or `256`                                                  → `"0"`-`"255"` (comma-separated list)
             * + or                 `"braille"`,                                                                → `'⠀'`-`'⣿'` (Unicode Braille Pattern) `0x2800`-`0x28FF`
             * @returns {BigIntType} `this` with no changes
             * @throws {SyntaxError} if `base` is not an available option
             */
            logConsole(base='x'){
                let _base='';
                switch(String(base).toLowerCase()){
                    case'b':case"bin":case"bit":case"binary":case'2':_base='2';break;
                    case'c':case"crumb":case'q':case"quaternary":case'4':_base='4';break;
                    case'o':case"oct":case"octal":case'8':_base='8';break;
                    case'd':case"dec":case"decimal":case"10":_base="10";break;
                    case'n':case"nibble":case'x':case'h':case"hex":case"hexadecimal":case"16":_base="16";break;
                    case't':case"text":case"bin-text":case"36":_base="36";break;
                    case"byte":case"256":_base="256";break;
                    case"braille":_base='0';break;
                    default:throw new SyntaxError("[logConsole] base is not an available option");
                }
                console.log(
                    "[%i]: (%i Bytes) %s (base %s)",
                    Date.now(),
                    this.length,
                    this.toString(base),
                    (_base==='0'?"256 Braille-Patterns":_base)
                );
                return this;
            }
            /**
             * __makes a copy of `this` number__
             * @returns {BigIntType} a copy of `this` number
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            copy(){return this.#sign?new BigIntType(this.#digits.slice(),"256"):new BigIntType(this.#digits.slice(),"256").neg();}
            /**
             * __copy values from `this` to `n`__
             * @param {BigIntType} n - number to set equal to `this` (will be modified)
             * @returns {BigIntType} `this` (unmodified)
             */
            reverseCopy(n){n.setEqualTo(this);return this;}
            /**
             * __set `this` number equal to `n`__
             * @param {BigIntType} n - number to set equal to (copy values from)
             * @returns {BigIntType} `this = n`
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            setEqualTo(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[setEqualTo] n is not an instance of BigIntType");}
                this.#digits=n.#digits.slice();
                this.#sign=n.#sign;
                return this;
            }
            /**
             * __sets `this` sign positive__
             * @returns {BigIntType} `this` number
             */
            abs(){this.#sign=true;return this;}
            /**
             * __negates/invertes `this` sign__
             * @returns {BigIntType} `this` number
             */
            neg(){this.#sign=!this.#sign;return this;}
            /**
             * __determines if `this` number is odd__
             * @returns {boolean} `this % 2 === 1`
             */
            isOdd(){return Boolean(this.#digits[0]&1);}
            /**
             * __determines if `this` number is even__
             * @returns {boolean} `this % 2 === 0`
             */
            isEven(){return !this.isOdd();}
            /**
             * __determines if `this` number is equal to 0__ \
             * _only compares digit not sign_
             * @returns {boolean} `abs(this) === 0`
             */
            isZero(){return(this.length===1&&this.#digits[0]===0);}
            /**
             * __determines if `this` number is equal to 1__ \
             * _only compares digit not sign_
             * @returns {boolean} `abs(this) === 1`
             */
            isOne(){return(this.length===1&&this.#digits[0]===1);}
            /**
             * __determines if `this` number is equal to 2__ \
             * _only compares digit not sign_
             * @returns {boolean} `abs(this) === 2`
             */
            isTwo(){return(this.length===1&&this.#digits[0]===2);}
            /**
             * __determines if `this` number is smaller than `n`__
             * @param {BigIntType} n - the second number for comparison
             * @returns {boolean} `this < n`
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             */
            isSmallerThan(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[isSmallerThan] n is not an instance of BigIntType");}
                if(!this.#sign&&n.#sign){return true;}
                if(this.#sign&&!n.#sign){return false;}
                if(this.#sign){
                    if(this.length<n.length){return true;}
                    if(this.length>n.length){return false;}
                    for(let i=this.length-1;i>=0;i--){
                        if(this.#digits[i]<n.#digits[i]){return true;}
                        if(this.#digits[i]>n.#digits[i]){return false;}
                    }
                    return false;
                }else{
                    if(this.length>n.length){return true;}
                    if(this.length<n.length){return false;}
                    for(let i=this.length-1;i>=0;i--){
                        if(this.#digits[i]>n.#digits[i]){return true;}
                        if(this.#digits[i]<n.#digits[i]){return false;}
                    }
                    return false;
                }
            }
            /**
             * __determines if `this` number is greater than `n`__
             * @param {BigIntType} n - the second number for comparison
             * @returns {boolean} `this > n`
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             */
            isGreaterThan(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[isGreaterThan] n is not an instance of BigIntType");}
                if(this.#sign&&!n.#sign){return true;}
                if(!this.#sign&&n.#sign){return false;}
                if(this.#sign){
                    if(this.length>n.length){return true;}
                    if(this.length<n.length){return false;}
                    for(let i=this.length-1;i>=0;i--){
                        if(this.#digits[i]>n.#digits[i]){return true;}
                        if(this.#digits[i]<n.#digits[i]){return false;}
                    }
                    return false;
                }else{
                    if(this.length<n.length){return true;}
                    if(this.length>n.length){return false;}
                    for(let i=this.length-1;i>=0;i--){
                        if(this.#digits[i]<n.#digits[i]){return true;}
                        if(this.#digits[i]>n.#digits[i]){return false;}
                    }
                    return false;
                }
            }
            /**
             * __determines if `this` number is equal to `n`__
             * @param {BigIntType} n - the second number for comparison
             * @returns {boolean} `this == n`
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             */
            isEqualTo(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[isEqualTo] n is not an instance of BigIntType");}
                if(this.#sign!==n.#sign){return false;}
                if(this.length!==n.length){return false;}
                return this.#digits.every((value,index)=>value===n.#digits[index]);
            }
            /**
             * __determines if `this` number is greater or equal to `n`__
             * @param {BigIntType} n - the second number for comparison
             * @returns {boolean} `this >= n`
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             */
            isGreaterOrEqualTo(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[isGreaterOrEqualTo] n is not an instance of BigIntType");}
                return !(this.isSmallerThan(n));
            }
            /**
             * __determines if `this` number is smaller or equal to `n`__
             * @param {BigIntType} n - the second number for comparison
             * @returns {boolean} `this <= n`
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             */
            isSmallerOrEqualTo(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[isSmallerOrEqualTo] n is not an instance of BigIntType");}
                return !(this.isGreaterThan(n));
            }
            /**
             * __removes (unnecessary) leading zeros from `digits`__
             * @param {Uint8Array|string[]} digits - digits-array (if `string[]` original will be altered)
             * @returns {Uint8Array|string[]} `digits` after removing all leading zeros (output type matches input type)
             */
            static #removeLeadingZeros(digits){
                /**@type {number} - index of first non-zero digit (from left)*/
                let first=digits.length-1;
                if(digits instanceof Uint8Array){
                    for(;first>0&&digits[first]===0;first--);
                    return digits.slice(0,first+1);
                }
                for(;first>0&&digits[first]==='0';first--);
                digits.splice(first+1);
                return digits;
            }
            /**
             * __applies the negative carry and returns new first-digit-index__ \
             * _used in `#calcDec()` and `#calcSub()`_ \
             * does not remove leading zeros
             * @param {string[]} digits - digits-array (original will be altered)
             * @param {number} i - current index
             * @param {number} first - current index of the first digit
             * @returns {number} new index for first digit
             */
            static #minusCarry(digits,i,first){
                let j=1;
                for(;digits[i+j]==='0';digits[i+j++]="255");
                digits[i+j]=String(Number(digits[i+j])-1);
                return(digits[i+j]==='0'&&i+j===first)?--first:first;
            }
            /**
             * __increment `digits` once__ \
             * _ignoring  initial sign_ \
             * does not remove leading zeros
             * @param {string[]} digits - digits-array (original will be altered)
             * @returns {string[]} digits-array after incrementing
             */
            static #calcInc(digits){
                digits[0]=String(Number(digits[0])+1);
                for(let i=0;i<digits.length;i++){
                    if(Number(digits[i])>=256){
                        digits[i]=String(Number(digits[i])%256);
                        digits[i+1]='1';
                    }else{break;}
                }
                return digits;
            }
            /**
             * __decrement `this` number by `1`__ \
             * _ignoring  initial sign_ \
             * does not remove leading zeros
             * @param {string[]} digits - digits-array (original will be altered)
             * @returns {Readonly<{_sign:boolean;_digits:string[]}>} `digits` and sign after decrementing
             */
            static #calcDec(digits){
                /**@type {boolean} - sign for digits */
                let sign=true;
                digits[0]=String(Number(digits[0])-1);
                if(digits[0]==="-1"){
                    if(digits.length===1){
                        sign=false;
                        digits[0]='1';
                    }else{
                        digits[0]='255';
                        BigIntType.#minusCarry(digits,0,digits.length-1);
                    }
                }
                return Object.freeze({_sign:sign,_digits:digits});
            }
            /**
             * __increments `this` number once__ \
             * _modifies the original_
             * @returns {BigIntType} `++ this`
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            inc(){
                /**@type {string[]} - digits-array */
                let _tmp=Array.from(this.#digits,String);
                if(this.#sign){this.#digits=new Uint8Array(BigIntType.#removeLeadingZeros(BigIntType.#calcInc(_tmp)));}
                else{
                    (({_sign,_digits})=>{
                        this.#digits=new Uint8Array(BigIntType.#removeLeadingZeros(_digits));
                        this.#sign=!_sign;
                    })(BigIntType.#calcDec(_tmp));
                }
                if(this.length>BigIntType.MAX_SIZE){throw new RangeError("[inc] would result in a number longer than MAX_SIZE");}
                return this;
            }
            /**
             * __decrements `this` number once__ \
             * _modifies the original_
             * @returns {BigIntType} `-- this`
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            dec(){
                /**@type {string[]} - digits-array */
                let _tmp=Array.from(this.#digits,String);
                if(this.#sign){
                    (({_sign,_digits})=>{
                        this.#digits=new Uint8Array(BigIntType.#removeLeadingZeros(_digits));
                        this.#sign=_sign;
                    })(BigIntType.#calcDec(_tmp));
                }else{this.#digits=new Uint8Array(BigIntType.#removeLeadingZeros(BigIntType.#calcInc(_tmp)));}
                if(this.length>BigIntType.MAX_SIZE){throw new RangeError("[dec] would result in a number longer than MAX_SIZE");}
                return this;
            }
            /**
             * __adds two numbers together__ \
             * _ignoring initial sign_ \
             * does not remove leading zeros
             * @param {string[]} A - first addend digits-array (original will be altered)
             * @param {string[]} B - second addend digits-array
             * @returns {string[]} `A + B` (modified `A`)
             */
            static #calcAdd(A,B){
                /**@type {number} - length of the longer array */
                const len=Math.max(A.length,B.length);
                for(let i=0,o=false;i<len||o;i++){
                    A[i]=String(Number(A[i]||0)+Number(B[i]||0)+(o?1:0));
                    if(Number(A[i])>=256){
                        A[i]=String(Number(A[i])%256);
                        o=true;
                    }else{o=false;}
                }
                return A;
            }
            /**
             * __subtracts two numbers from one another__ \
             * _ignoring initial sign_ \
             * does not remove leading zeros
             * @param {string[]} A - minuend digits-array (original will be altered)
             * @param {string[]} B - subtrahend digits-array
             * @returns {Readonly<{_sign:boolean;_digits:string[]}>} `A - B` (modified `A` with sign)
             */
            static #calcSub(A,B){
                /**@type {number} - length of the longer number */
                const len=Math.max(A.length,B.length);
                /**@type {number} - current index of the first digit */
                let first=len-1,
                    /**@type {boolean} - current sign of number */
                    sign=true;
                for(let i=first;i>=0;i--){
                    A[i]=String(Number(A[i]||0)-Number(B[i]||0));
                    if(A[i]==='0'){
                        if(i===first){first--;}
                    }else if(A[i][0]==='-'){//~ <0
                        if(!sign){A[i]=A[i].substring(1);}//~ abs()
                        else if(i===first){
                            sign=false;
                            A[i]=A[i].substring(1);//~ abs()
                        }else{
                            A[i]=String(Number(A[i])+256);
                            first=BigIntType.#minusCarry(A,i,first);
                        }
                    }else if(!sign){
                        A[i]=String(Math.abs(Number(A[i])-256));
                        first=BigIntType.#minusCarry(A,i,first);
                    }
                }
                return Object.freeze({_sign:sign,_digits:A});
            }
            /**
             * __adds another number to `this` one__ \
             * _modifies the original_
             * @param {BigIntType} n - second number for addition
             * @returns {BigIntType} `this + n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            add(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[add] n is not an instance of BigIntType");}
                let [A,B]=[Array.from(this.#digits,String),Array.from(n.#digits,String)];
                if(this.#sign===n.#sign){//~ (+)+(+) || (-)+(-)
                    BigIntType.#calcAdd(A,B);
                    BigIntType.#removeLeadingZeros(A);
                    if(A.length>BigIntType.MAX_SIZE){throw new RangeError("[add] would result in a number longer than MAX_SIZE");}
                    this.#digits=new Uint8Array(A);
                }else{
                    if(this.#sign){//~ (+)+(-)
                        this.#sign=BigIntType.#calcSub(A,B)._sign;
                        BigIntType.#removeLeadingZeros(A);
                        if(A.length>BigIntType.MAX_SIZE){throw new RangeError("[add] would result in a number longer than MAX_SIZE");}
                        this.#digits=new Uint8Array(A);
                    }else{//~ (-)+(+)
                        this.#sign=BigIntType.#calcSub(B,A)._sign;
                        BigIntType.#removeLeadingZeros(B);
                        if(B.length>BigIntType.MAX_SIZE){throw new RangeError("[add] would result in a number longer than MAX_SIZE");}
                        this.#digits=new Uint8Array(B);
                    }
                }
                return this;
            }
            /**
             * __subtracts another number from `this` one__ \
             * _modifies the original_
             * @param {BigIntType} n - second number for subtraction (subtrahend)
             * @returns {BigIntType} `this - n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            sub(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[sub] n is not an instance of BigIntType");}
                let [A,B]=[Array.from(this.#digits,String),Array.from(n.#digits,String)];
                if(this.#sign!==n.#sign){//~ (+)-(-) || (-)-(+)
                    BigIntType.#calcAdd(A,B);
                    BigIntType.#removeLeadingZeros(A);
                    if(A.length>BigIntType.MAX_SIZE){throw new RangeError("[sub] would result in a number longer than MAX_SIZE");}
                    this.#digits=new Uint8Array(A);
                }else{
                    if(this.#sign){//~ (+)-(+)
                        this.#sign=BigIntType.#calcSub(A,B)._sign;
                        BigIntType.#removeLeadingZeros(A);
                        if(A.length>BigIntType.MAX_SIZE){throw new RangeError("[sub] would result in a number longer than MAX_SIZE");}
                        this.#digits=new Uint8Array(A);
                    }else{//~ (-)-(-)
                        this.#sign=BigIntType.#calcSub(B,A)._sign;
                        BigIntType.#removeLeadingZeros(B);
                        if(B.length>BigIntType.MAX_SIZE){throw new RangeError("[sub] would result in a number longer than MAX_SIZE");}
                        this.#digits=new Uint8Array(B);
                    }
                }
                return this;
            }
            /**
             * __multiplies `this` number with 256 to the power of `x`__ \
             * _shifts the digits by `x` amount, positive=left, with `rounding` in respect to base 256_
             * @param {number} x - exponent - save integer
             * @param {string} rounding - how to round when digit-shifting right _default `'r'`_
             * + `'r'` or `"round"` auto rounds possible decimal places
             * + `'f'` or `"floor"` rounds down possible decimal places
             * + `'c'` or `"ceil"` rounds up possible decimal places
             * @returns {BigIntType} - `this` number after multiplication/digit-shifts
             * @throws {TypeError} - if `x` is not a save integer
             * @throws {SyntaxError} - if `rounding` is not a valid option (see `rounding`s doc.)
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            times256ToThePowerOf(x,rounding='r'){
                x=Number(x);if(!Number.isSafeInteger(x)){throw new TypeError("[times256ToThePowerOf] x is not a save integer");}
                rounding=String(rounding);if(!/^(r|round|f|floor|c|ceil)$/.test(rounding)){throw new SyntaxError("[times256ToThePowerOf] rounding is not a valid option");}
                if(this.isZero()){return this;}
                if(x>0){
                    if(x+this.length>BigIntType.MAX_SIZE){throw new RangeError(`[times256ToThePowerOf] n digit-shifts would result in a number longer than MAX_SIZE`);}
                    this.#digits=new Uint8Array([...new Uint8Array(x),...this.#digits]);
                }else if(x<0){
                    x=Math.abs(x);
                    if(x>=this.length){
                        switch(rounding){
                            case'c':case"ceil":this.#digits=new Uint8Array([1]);break;
                            case'f':case"floor":this.#digits=new Uint8Array([0]);break;
                            case'r':case"round":this.#digits=new Uint8Array([x===this.length?Number(this.#digits[0]>=128):0]);break;
                        }
                    }else{
                        this.#digits=this.#digits.slice(x);
                        switch(rounding){
                            case'c':case"ceil":if(this.#digits[x]!==0){this.#calcInc();}break;
                            case'r':case"round":if(this.#digits[x]>=128){this.#calcInc();}break;
                        }
                    }
                }
                return this;
            }
            /**
             * __shifts the bits of `this` number to the right `x` amount__ \
             * sign is not affected \
             * _modifies the original_
             * @param {number} x - number of times to bitshift to the right (save integer) - _default `1`_
             * @returns {BigIntType} `this >>> x` (`this` modified)
             * @throws {TypeError} - if `x` is not a positive save integer
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            bitShiftR(x=1){
                x=Number(x);if(x<0||!Number.isSafeInteger(x)){throw new TypeError("[bitshiftR] x is not a positive save integer");}
                this.times256ToThePowerOf(-(Math.floor(x/8)),'f');
                x=x%8
                if(x===0){return this;}
                for(let i=0;i<this.length;i++){
                    this.#digits[i]>>>=x;
                    this.#digits[i]|=((this.#digits[i+1]||0)&((1<<x)-1))<<(8-x);//~ add the right x bits from [i+1] to the left of [i] (8bits)
                }
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                return this;
            }
            /**
             * __shifts the bits of `this` number to the left `x` amount__ \
             * sign is not affected \
             * _modifies the original_
             * @param {number} x - number of times to bitshift to the left (save integer) - _default `1`_
             * @returns {BigIntType} `this << x` (`this` modified)
             * @throws {TypeError} - if `x` is not a positive save integer
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            bitShiftL(x=1){
                x=Number(x);if(x<0||!Number.isSafeInteger(x)){throw new TypeError("[bitshiftL] x is not a positive save integer");}
                if(Math.floor(x/8)+this.length>BigIntType.MAX_SIZE){throw new RangeError(`[bitshiftL] would result in a number longer than MAX_SIZE`);}
                this.times256ToThePowerOf(Math.floor(x/8));
                x=x%8
                if(x===0){return this;}
                this.#digits=new Uint8Array([...this.#digits,0]);
                for(let i=this.length-1;i>=0;i--){
                    this.#digits[i]<<=x;
                    this.#digits[i]|=((this.#digits[i-1]||0)&(((1<<x)-1)<<(8-x)))>>>(8-x);//~ add the left x bits from [i-1] to the right of [i] (8bits)
                }
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                if(this.length>BigIntType.MAX_SIZE){throw new RangeError("[bitshiftL] would result in a number longer than MAX_SIZE");}
                return this;
            }
            /**
             * __applies bitwise AND with `this` and `n`__ \
             * sign is not affected \
             * _modifies the original_
             * @param {BigIntType} n - second number
             * @returns {BigIntType} `this & n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            bitAND(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[bitAND] n is not an instance of BigIntType");}
                if(this.length<n.length){this.#digits=new Uint8Array([...this.#digits,...new Uint8Array(n.length-this.length)]);}
                for(let i=0;i<this.length;i++){this.#digits[i]&=(n.#digits[i]||0);}
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                return this;
            }
            /**
             * __applies bitwise OR with `this` and `n`__ \
             * sign is not affected \
             * _modifies the original_
             * @param {BigIntType} n - second number
             * @returns {BigIntType} `this | n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            bitOR(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[bitOR] n is not an instance of BigIntType");}
                if(this.length<n.length){this.#digits=new Uint8Array([...this.#digits,...new Uint8Array(n.length-this.length)]);}
                for(let i=0;i<this.length;i++){this.#digits[i]|=(n.#digits[i]||0);}
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                return this;
            }
            /**
             * __applies bitwise XOR with `this` and `n`__ \
             * sign is not affected \
             * _modifies the original_
             * @param {BigIntType} n - second number
             * @returns {BigIntType} `this ^ n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            bitXOR(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[bitXOR] n is not an instance of BigIntType");}
                if(this.length<n.length){this.#digits=new Uint8Array([...this.#digits,...new Uint8Array(n.length-this.length)]);}
                for(let i=0;i<this.length;i++){this.#digits[i]^=(n.#digits[i]||0);}
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                return this;
            }
            /**
             * __applies bitwise NOT with `this` number__ \
             * sign is not affected \
             * _modifies the original_
             * @returns {BigIntType} `~ this` (`this` modified)
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            bitNOT(){
                for(let i=0;i<this.length;i++){this.#digits[i]=~this.#digits[i];}
                this.#digits=BigIntType.#removeLeadingZeros(this.#digits);
                return this;
            }
            /**
             * __calculates half of `this` number__ \
             * _modifies the original_
             * @param {string} rounding - _default `'c'`_
             * + `'c'` or `"ceil"` for rounding up the result
             * + `'f'` or `"floor"` for rounding down the result
             * @returns {BigIntType} `this / 2` (`this` modified)
             * @throws {SyntaxError} - if `rounding` is not a valid option
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            half(rounding='c'){
                rounding=String(rounding);if(!/^(c|ceil|f|floor)$/.test(rounding)){throw new SyntaxError("[half] rounding is not a valid option");}
                if(this.isZero()){return this;}
                if(this.isOdd()&&(rounding==='c'||rounding==="ceil")){return this.bitShiftR(1).inc();}
                else{return this.bitShiftR(1);}
            }
            /**
             * __calculates double of `this` number__ \
             * _modifies the original_
             * @returns {BigIntType} `this * 2` (`this` modified)
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            double(){
                try{this.bitShiftL(1);}
                catch(error){throw (error instanceof RangeError)?new RangeError(`[double] would result in a number longer than MAX_SIZE`):error;}
                return this;
            }
            /**
             * __divides one number from another one__ \
             * _ignoring initial sign_ \
             * [!] `A`>`B`>0
             * @param {Uint8Array} A - dividend (>`B`)
             * @param {Uint8Array} B - divisor (>0)
             * @returns {Readonly<{quotient:Uint8Array;remainder:Uint8Array}>} `A / B` (quotient with remainder)
             */
            static #calcDivRest(A,B){
                let Q=new Uint8Array(A.length+1),
                    R=new Uint8Array(B.length+1);
                /**
                 * @param {Uint8Array} a - digit-array R
                 * @param {Uint8Array} b - digit-array B
                 * @returns {boolean} `a>=b`
                 */
                const greaterEqual=(a,b)=>{
                    for(let i=a.length-2;i>=0;i--){
                        if(a[i]<b[i]){return false;}
                        if(a[i]>b[i]){return true;}
                    }
                    return true;
                };
                for(let i=A.length-1,j=7,k=0,z=0,m=0,l=0;i>=0;(j===0?(--i,j=7):--j)){//~ [i,j] for bit position / [k,m,l] other for-loop indexes / [z] a calculation result
                    for(k=R.length-1;k>=0;k--){//~ R<<=1
                        R[k]<<=1;
                        R[k]|=((R[k-1]||0)&128)>>>7;
                    }
                    R[0]|=(A[i]&(1<<j))>>>j;
                    if(R[R.length-1]>0||greaterEqual(R,B)){//~ R>=B
                        for(z=0,m=0,l=R.length-1;l>=0;l--){//~ R-=B
                            z=R[l]-(B[l]||0);
                            if(z<0){
                                R[l]=256+z;
                                for(m=l+1;R[m]===0;R[m++]=255);//~ minus carry
                                R[m]--;
                            }else{R[l]=z;}
                        }
                        Q[i]|=1<<j;
                    }
                }
                return Object.freeze({quotient:BigIntType.#removeLeadingZeros(Q),remainder:BigIntType.#removeLeadingZeros(R)});
            }
            /**
             * __divides another number from `this` one__ \
             * _modifies the original_
             * @param {BigIntType} n - divisor
             * @param {string} rounding - _default `'r'`_
             * + `'r'` or `"round"` for rounded division result
             * + `'f'` or `"floor"` for floored division result
             * + `'c'` or `"ceil"` for ceiled division result
             * @returns {BigIntType} `this / n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - if `n` is `0`
             * @throws {SyntaxError} - if `rounding` is not a valid option
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            div(n,rounding='r'){
                if(!(n instanceof BigIntType)){throw new TypeError("[div] n is not an instance of BigIntType");}
                rounding=String(rounding);if(!/^(r|round|f|floor|c|ceil)$/.test(rounding)){throw new SyntaxError("[div] rounding is not a valid option");}
                // dividend / divisor = quotient + remainder / divisor
                if(n.isZero()){throw new RangeError("[div] n is 0");}
                if(this.isZero()||n.isOne()){return n.#sign?this:this.neg();}
                if(n.length>1&&n.#digits.every((v,i,a)=>(i<a.length-1&&v===0)||(i===a.length-1&&v===1))){this.times256ToThePowerOf(1-n.length,rounding);}
                else if(this.copy().abs().isSmallerThan(n.copy().abs())){
                    switch(rounding){
                        case'c':case"ceil":this.#digits=new Uint8Array([1]);break;
                        case'f':case"floor":this.#digits=new Uint8Array([0]);break;
                        case'r':case"round":this.#digits=new Uint8Array([n.copy().abs().isGreaterThan(this.copy().abs().double())?0:1]);break;
                    }
                }else if(this.isEqualTo(n)){this.#digits=new Uint8Array([1]);}
                else{
                    /**@type {BigIntType[]}*/
                    let [q,r]=(({quotient,remainder})=>[
                        new BigIntType(quotient,"256"),
                        new BigIntType(remainder,"256")
                    ])(BigIntType.#calcDivRest(this.#digits,n.#digits));
                    switch(rounding){
                        case'c':case"ceil":
                            if(!(r.isZero())){q.inc();}
                            this.#digits=q.#digits;
                            break;
                        case'f':case"floor":this.#digits=q.#digits;break;
                        case'r':case"round":
                            if(r.isZero()||r.copy().double().isSmallerThan(q)){this.#digits=q.#digits;}
                            else{this.#digits=q.inc().#digits;}
                            break;
                    }
                }
                this.#sign=!(this.#sign^n.#sign);
                return this;
            }
            /**
             * __calculates modulo `n` of `this` number__ \
             * _modifies the original_
             * @param {BigIntType} n - second number (!=0)
             * @param {string} type - _default `'e'`_
             * + `'e'` or `"euclid"` for euclidean modulo remainder
             * + `'t'` or `"trunc"` for truncated modulo remainder - (like js `%`operator)
             * + `'f'` or `"floor"` for floored modulo remainder
             * + `'c'` or `"ceil"` for ceiled modulo remainder
             * + `'r'` or `"round"` for rounded modulo remainder
             * @returns {BigIntType} the modulo according to `type` as a new `BigIntType` number
             * @throws {TypeError} - if `n` is not a `BigIntType`
             * @throws {RangeError} - if `n` is `0`
             * @throws {SyntaxError} - if `type` is not a valid option
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            modulo(n,type='e'){
                if(!(n instanceof BigIntType)){throw new TypeError("[modulo] n is not an instance of BigIntType");}
                type=String(type);if(!/^(e|euclid|t|trunc|f|floor|c|ceil|r|round)$/.test(type)){throw new SyntaxError("[modulo] type is not a valid option");}
                if(n.isZero()){throw new RangeError("[modulo] n cannot divide by 0");}
                if(this.isZero()||n.isOne()){this.#digits=new Uint8Array([0]);return this;}
                if(n.isTwo()){this.#digits=new Uint8Array([Number(this.isOdd())]);return this;}
                let[_A,_B]=[this.copy().abs(),n.copy().abs()];
                /**@type {BigIntType} - rest */
                let R;
                if(_A.isSmallerThan(_B)){R=_A}
                else if(_A.isEqualTo(_B)){R=BigIntType.Zero;}
                else{R=new BigIntType(BigIntType.#calcDivRest(_A.#digits,_B.#digits).remainder,"256");}
                switch(type){
                    case'e':case"euclid":this.setEqualTo(this.#sign?R:_B.sub(R));break;
                    case't':case"trunc":this.setEqualTo(this.#sign?R:R.neg());break;
                    case'f':case"floor":this.setEqualTo(n.#sign?(this.#sign?R:_B.sub(R)):(this.#sign?R.sub(_B):R.neg()));break;
                    case'c':case"ceil":this.setEqualTo(n.#sign?(this.#sign?R.sub(_B):R.neg()):(this.#sign?R:_B.sub(R)));break;
                    case'r':case"round":this.setEqualTo(R.copy().sub(_B.copy().half('c')).#sign?(this.#sign?R.sub(_B):_B.sub(R)):(this.#sign?R:R.neg()));break;
                }
                return this;
            }
            /**
             * __Karatsubas Multiplication Algorithm__ \
             * _with recursion_ \
             * for `mul()`
             * @param {string[]} X - multiplicand digits-array
             * @param {string[]} Y - multiplicator digits-array
             * @description [!] initial `X` and `Y` same length → power of 2 (pad end with `0`)
             * @returns {string[]} `X * Y`
             */
            static #calcKaratsuba(X,Y){
                if(X.every(v=>v==='0')||Y.every(v=>v==='0')){return ['0'];}
                //~ assume here that`X` and `Y` are of same length and the length is a power of 2
                if(X.length===1){//~ small enough to conpute savely with JS-Number
                    const A=Number(X[0])*Number(Y[0]);
                    return[String(A&255),String(A>>>8)];
                }
                let Xl=X.slice(0,Math.floor(X.length*.5)),Xh=X.slice(Math.floor(X.length*.5)),
                    Yl=Y.slice(0,Math.floor(Y.length*.5)),Yh=Y.slice(Math.floor(Y.length*.5));
                let P3Calc1=BigIntType.#removeLeadingZeros(BigIntType.#calcAdd(Xh.slice(),Xl)),
                    P3Calc2=BigIntType.#removeLeadingZeros(BigIntType.#calcAdd(Yh.slice(),Yl)),P3Count=1;
                for(const max=Math.max(P3Calc1.length,P3Calc2.length);P3Count<max;P3Count*=2);
                let [P1,P2,P3]=[
                    BigIntType.#calcKaratsuba(Xh,Yh),
                    BigIntType.#calcKaratsuba(Xl,Yl),
                    BigIntType.#calcKaratsuba([...P3Calc1,...new Array(P3Count-P3Calc1.length).fill('0')],[...P3Calc2,...new Array(P3Count-P3Calc2.length).fill('0')])
                ];
                return BigIntType.#removeLeadingZeros(BigIntType.#calcAdd(
                    BigIntType.#calcAdd(
                        [...new Array(X.length).fill('0'),...P1.slice()],
                        [...new Array(Xh.length).fill('0'),...BigIntType.#removeLeadingZeros(BigIntType.#calcSub(P3,BigIntType.#calcAdd(P1.slice(),P2))._digits)]
                    ),P2
                ));
            }
            /**
             * __multiplies `this` number by `n`__ \
             * _modifies the original_
             * _using Karatsubas algorithm_
             * @param {BigIntType} n - multiplicator
             * @returns {BigIntType} `this * n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            mul(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[mul] n is not an instance of BigIntType");}
                if(this.isOne()&&n.isOne());
                else if(this.isOne()){this.#digits=n.#digits.slice();}
                else if(n.isOne());
                else if(n.isTwo()){
                    try{this.double();}
                    catch(e){throw (e instanceof RangeError)?new RangeError("[mul] would result in a number longer than MAX_SIZE"):e;}
                }else if(this.isTwo()){
                    try{this.#digits=n.copy().double().#digits;}
                    catch(e){throw (e instanceof RangeError)?new RangeError("[mul] would result in a number longer than MAX_SIZE"):e;}
                }else if(n.length>1&&n.#digits.every((v,i,a)=>(i<a.length-1&&v===0)||(i===a.length-1&&v===1))){
                    if((n.length-1)+this.length>BigIntType.MAX_SIZE){throw new RangeError("[mul] would result in a number longer than MAX_SIZE");}
                    this.times256ToThePowerOf(n.length-1,'f');
                }else{
                    /**@type {number} - length (a power of 2) for karatsuba-algorithm-numbers */
                    let len=1;
                    for(const max=Math.max(this.length,n.length);len<max;len*=2);
                    try{
                        this.#digits=new Uint8Array(BigIntType.#removeLeadingZeros(BigIntType.#calcKaratsuba(
                            [...Array.from(this.#digits,String),...new Array(len-this.length).fill('0')],
                            [...Array.from(n.#digits,String),...new Array(len-n.length).fill('0')]
                        )));
                    }catch(e){throw(e instanceof RangeError)?new RangeError("[mul] would result in a number longer than MAX_SIZE"):e;}
                    if(this.length>BigIntType.MAX_SIZE){new RangeError("[mul] would result in a number longer than MAX_SIZE");}
                }
                this.#sign=this.#sign===n.#sign;
                return this;
            }
            /**
             * __raises `this` number to the power of `n`__ \
             * _modifies the original_
             * @param {BigIntType} n - exponent
             * @returns {BigIntType} `this ** n` (`this` modified)
             * @throws {TypeError} - if `n` is not an instance of `BigIntType`
             * @throws {RangeError} - if `this` is 0 and `n` is negative (inverse of 0 → division by 0)
             * @throws {RangeError} - if `n` is negative (and `this` not 1 or 0) (inverse of integers does not exist except for 1)
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            pow(n){
                if(!(n instanceof BigIntType)){throw new TypeError("[pow] n is not an instance of BigIntType");}
                if(n.isZero()){return this.setEqualTo(BigIntType.One);}
                if(this.isZero()){
                    if(n.#sign){return this;}
                    throw new RangeError("[pow] can not calculate zero to the power of a negative exponent");
                }
                if(this.isOne()){return this;}
                if(n.isOne()&&n.#sign){return this;}
                if(!n.#sign){throw new RangeError("[pow] can not calculate the inverse of integers other than 1");}
                /**@type {string[]} - final number */
                let result=['1'];
                for(let karatsubaLen=0,base=Array.from(this.#digits,String),exp=Array.from(n.#digits,String);;){
                    if(Number(exp[0])&1){
                        BigIntType.#removeLeadingZeros(result);
                        BigIntType.#removeLeadingZeros(base);
                        for(karatsubaLen=1;karatsubaLen<Math.max(result.length,base.length);karatsubaLen*=2);//~ result*=base
                        result=BigIntType.#calcKaratsuba(
                            [...result,...new Array(karatsubaLen-result.length).fill('0')],
                            [...base,...new Array(karatsubaLen-base.length).fill('0')]
                        );
                    }
                    for(let i=0;i<exp.length;i++){//~ exp>>>=1
                        exp[i]=String(Number(exp[i])>>>1);
                        exp[i]=String(Number(exp[i])|(Number(exp[i+1]||0)&1)<<7);
                    }
                    if(exp.every(v=>v==='0')){break;}
                    BigIntType.#removeLeadingZeros(base);
                    for(karatsubaLen=1;karatsubaLen<base.length;karatsubaLen*=2);//~ base*=base
                    base=BigIntType.#calcKaratsuba(
                        [...base,...new Array(karatsubaLen-base.length).fill('0')],
                        [...base,...new Array(karatsubaLen-base.length).fill('0')]
                    );
                    if(result.length>2147483648||base.length>2147483648){throw new RangeError("[pow] would result in a number longer than MAX_SIZE");}//~ safety? (2GiB)
                }
                BigIntType.#removeLeadingZeros(result);
                if(result.length>BigIntType.MAX_SIZE){throw new RangeError("[pow] would result in a number longer than MAX_SIZE");}
                this.#digits=new Uint8Array(result);
                if(n.isEven()){this.abs();}
                return this;
            }
            /**
             * __maps `this` number from one range to another__ \
             * _modifies the original_
             * @param {BigIntType} initialLow - initial lower bound
             * @param {BigIntType} initialHigh - initial higher bound
             * @param {BigIntType} finalLow - final lower bound
             * @param {BigIntType} finalHigh - final higher bound
             * @param {string} rounding - _default `'r'`_
             * + `'r'` or `"round"` for rounded result
             * + `'f'` or `"floor"` for floored result
             * + `'c'` or `"ceil"` for ceiled result
             * @param {boolean} limit - if `true` caps the result at final bound
             * @returns {BigIntType} `this` in `finalLow` to `finalHigh` range (rounded/caped as set) (`this` modified)
             * @throws {TypeError} - if `initialLow`,`initialHigh`,`finalLow` or `finalHigh` are not instances of `BigIntType`
             * @throws {RangeError} - if `initialLow` and `initialHigh` or `finalLow` and `finalHigh` are the same value
             * @throws {SyntaxError} - if `rounding` is not a valid option
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            mapRange(initialLow,initialHigh,finalLow,finalHigh,rounding='r',limit=false){
                if(!(initialLow instanceof BigIntType)){throw new TypeError("[mapRange] initialLow is not an instance of BigIntType");}
                if(!(initialHigh instanceof BigIntType)){throw new TypeError("[mapRange] initialHigh is not an instance of BigIntType");}
                if(!(finalLow instanceof BigIntType)){throw new TypeError("[mapRange] finalLow is not an instance of BigIntType");}
                if(!(finalHigh instanceof BigIntType)){throw new TypeError("[mapRange] finalHigh is not an instance of BigIntType");}
                if(initialLow.isEqualTo(initialHigh)){throw new RangeError("[mapRange] initialLow and initialHigh are the same value");}
                if(finalLow.isEqualTo(finalHigh)){throw new RangeError("[mapRange] finalLow and finalHigh are the same value");}
                rounding=String(rounding);if(!/^(r|round|f|floor|c|ceil)$/.test(rounding)){throw new SyntaxError("[mapRange] rounding is not a valid option");}
                limit=Boolean(limit);
                try{
                    initialHigh=initialHigh.copy().sub(initialLow);
                    this.sub(initialLow)
                        .mul(finalHigh.copy().sub(finalLow))
                        .add(initialHigh.copy().mul(finalLow))
                        .div(initialHigh,rounding);
                }catch(error){
                    if(error instanceof RangeError)throw new RangeError("[mapRange] would result in a number longer than MAX_SIZE");
                    throw error;
                }
                if(limit){
                    if(this.isSmallerThan(finalLow)){this.setEqualTo(finalLow);}
                    else if(this.isGreaterThan(finalHigh)){this.setEqualTo(finalHigh);}
                }
                if(this.length>BigIntType.MAX_SIZE){throw new RangeError("[mapRange] would result in a number longer than MAX_SIZE");}
                return this;
            }
            /**
             * __calculates the greatest common divisor of `a` and `b`__
             * @param {BigIntType} a - first number
             * @param {BigIntType} b - second number
             * @returns {BigIntType} gcd of `a` and `b` so that `(a/gcd) / (b/gcd)` will be the smallest possible (integer) fraction
             * @throws {TypeError} - if `a` or `b` are not instances of `BigIntType`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static GCD(a,b){
                if(!(a instanceof BigIntType)){throw new TypeError("[GCD] a is not an instance of BigIntType");}
                if(!(b instanceof BigIntType)){throw new TypeError("[GCD] b is not an instance of BigIntType");}
                let [A,B]=(a.isSmallerThan(b))?[b.#digits,a.#digits]:[a.#digits,b.#digits];
                for(let last=new Uint8Array(1);(last=BigIntType.#calcDivRest(A,B).remainder,(last.length>1||last[0]!==0));[A,B]=[B,last]);
                return new BigIntType(B.slice(),"256");
            }
            /**
             * __creates a random number using `Math.random()`'s binary output__ \
             * _not cryptographically secure output_
             * @param {BigIntType} min - lower limit (included) - _default `0`_
             * @param {BigIntType} max - upper limit (included) - _default `1.79e308` (`BigIntType.Infinity`)_
             * @returns {BigIntType} random number between `min` and `max`
             * @throws {TypeError} - if `min` or `max` are not instances of `BigIntType`
             * @throws {RangeError} - if new number would be longer than `BigIntType.MAX_SIZE`
             * @throws {RangeError} - _if some Array could not be allocated (system-specific & memory size)_
             */
            static randomInt(min=BigIntType.Zero,max=BigIntType.Infinity){
                try{
                    return new BigIntType(new Uint8Array(BigIntType.#removeLeadingZeros([...Math.random().toString(2).substring(2)].reverse())),'2').mapRange(
                        BigIntType.Zero,
                        new BigIntType(new Uint8Array([255,255,255,255,255,255,15]),"256"),
                        min,max,
                        'r',true
                    );
                }catch(error){
                    if(error instanceof RangeError)throw new RangeError("[randomInt] would result in a number longer than MAX_SIZE");
                    throw error;
                }
            }
        } //~ or just u know use the actual BigInt xD - it might not have base 256 and a few of the methods here but it's a lot faster since it's coded on a lower level ^^
        // TODO {see Math-Js/BigIntType.js}
    </script>
    <script>
        /**
         * __constructs a RegExp to match `base`__ \
         * _min 1 digit_ \
         * match-groups:
         * 1. sign / null
         * 2. number / comma-separated list of numbers
         * @param {number} base - base 0=braille, 2-10 [0-9], 11-36 [0-9A-F], 37-256 [0-9](comma-separated list of numbers)
         * @returns {RegExp} regexp for `base` - if out of range only matches `+0` and `-0`
         */
        const _REGEXP_STRING=base=>{
            // TODO add support for ignoring '_' after prefix and between digits (except comma separated list)
            base=Math.abs(Number(base));if(Number.isNaN(base)){return/^([+-]?)(0)$/;}
            switch(Number(base)){
                case 0:return/^([+-]?)(\u2800|[\u2801-\u28FF][\u2800-\u28FF]*)$/;// unicode braille-pattern
                case 1:return/^([+-]?)(0)$/;//~ base 1 does not exist
                case 2:return/^([+-]?)(?:0b)?(0|1[01]*)$/i;
                case 8:return/^([+-]?)(?:0o)?(0|[1-7][0-7]*)$/i;
                case 16:return/^([+-]?)(?:0x)?(0|[1-9A-F][0-9A-F]*)$/i;
                default:// all bases up to 256
                    if(base<=10){return new RegExp(`^([+-]?)(0|[1-${base-1}][0-${base-1}]*)$`);}
                    else if(base<=36){return new RegExp(`^([+-]?)(0|[1-9A-${String.fromCharCode(54+base)}][0-9A-${String.fromCharCode(54+base)}]*)$`,'i');}
                    else if(base<=256){// 37-256 (comma-separated list of numbers)
                        const _base=String(base);
                        if(_base.length===2){// "37"-"99" (~"10"-"99")
                            return new RegExp(
                                `^([+-]?)((?:[0-9]${
                                    (_base[0]!=='1'?`|[1-${Number(_base[0])-1}][0-9]`:'')
                                    +(_base[1]!=='0'?`|${_base[0]}[0-${Number(_base[1])-1}]`:'')
                                })(?:\,(?:[0-9]${
                                    (_base[0]!=='1'?`|[1-${Number(_base[0])-1}][0-9]`:'')
                                    +(_base[1]!=='0'?`|${_base[0]}[0-${Number(_base[1])-1}]`:'')
                                }))*)$`
                            );
                        }else if(_base.length===3){// "100"-"256" (~"100"-"999")
                            return new RegExp(
                                `^([+-]?)((?:[1-9]?[0-9]${
                                    (_base[0]!=='1'?`|[1-${Number(_base[0])-1}][0-9][0-9]`:'')
                                    +(_base[1]!=='0'?`|${_base[0]}[0-${Number(_base[1])-1}][0-9]`:'')
                                    +(_base[2]!=='0'?`|${_base[0]}${_base[1]}[0-${Number(_base[2])-1}]`:'')
                                })(?:\,(?:[1-9]?[0-9]${
                                    (_base[0]!=='1'?`|[1-${Number(_base[0])-1}][0-9][0-9]`:'')
                                    +(_base[1]!=='0'?`|${_base[0]}[0-${Number(_base[1])-1}][0-9]`:'')
                                    +(_base[2]!=='0'?`|${_base[0]}${_base[1]}[0-${Number(_base[2])-1}]`:'')
                                }))*)$`
                            );
                        }
                    }
                    break;
            }
            return/^([+-]?)(0)$/;//~ no more bases implemented
        };
        /**__numbers as BigIntType objects stored in this convenient object__*/
        let _NUMBERS=Object.freeze({
                /**@type {BigIntType[]}*/
                mem:[],//~ max 10 memory numbers
                a:BigIntType.One,
                b:BigIntType.Zero,
                rand:Object.freeze({
                    min:BigIntType.Zero,
                    max:new BigIntType("1000000","10"),
                }),
                map:Object.freeze({
                    min1:BigIntType.Zero,
                    max1:new BigIntType("1000000","10"),
                    min2:new BigIntType("1000000","10"),
                    max2:BigIntType.Zero,
                }),
            }),
            /**@type {number} current memory size of all numbers*/
            _CURRENT_MEM_SIZE=500,
            /**@type {string} current radix of all numbers*/
            _CURRENT_BASE="10";
        /**
         * __prints the `message` to the html-error-element__ \
         * auto resize to fit-content
         * @param {string} message - message to print
         */
        function _error_html(message){
            error_output.value=message;
            error_output.style.height="";
            error_output.style.height=error_output.scrollHeight + "px";
        }
        /**
         * __custom validity `message` for `element`__
         * @param {HTMLElement} element - element to apply
         * @param {string} message - message to apply
         */
        function _error_css(element,message){
            element.setCustomValidity(message);
            element.reportValidity();
        }
        /**
         * __checks if number input is in correct base format__ \
         * _and reports if not valid_
         * @param {HTMLElement} element - html element
         */
        function _numberInput(element){
            if(!(_REGEXP_STRING(_CURRENT_BASE==="braille"?0:Number(_CURRENT_BASE)).test(element.value))){_error_css(element,"not in correct format for base "+(_CURRENT_BASE===0?"256(braille)":_CURRENT_BASE));}
            else{_error_css(element,"");}
        }
        /**
         * __checks if number entered is in correct base format__ \
         * _and reports if not valid_ \
         * set number variable if entered number is valid \
         * and sets the A to B comparison field
         * @param {HTMLElement} element - html element
         */
        function _numberChange(element){
            _error_html("");
            _error_css(element,"");
            if(_REGEXP_STRING(_CURRENT_BASE==="braille"?0:Number(_CURRENT_BASE)).test(element.value)){
                try{
                    switch(element.id){
                        case"number_a":_NUMBERS.a.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"number_b":_NUMBERS.b.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"Arandommin":_NUMBERS.rand.min.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"Arandommax":_NUMBERS.rand.max.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"Amapmin1":_NUMBERS.map.min1.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"Amapmax1":_NUMBERS.map.max1.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"Amapmin2":_NUMBERS.map.min2.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                        case"Amapmax2":_NUMBERS.map.max2.setEqualTo(new BigIntType(element.value,_CURRENT_BASE));break;
                    }
                    if(element.id==="number_a"||element.id==="number_b"){AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;}
                }catch(error){
                    console.error(error);
                    _error_html(`{InputError} reseted number entered because it was to large\ninput:\n${element.value}`);
                    switch(element.id){
                        case"number_a":element.value=_NUMBERS.a.toString(_CURRENT_BASE);break;
                        case"number_b":element.value=_NUMBERS.b.toString(_CURRENT_BASE);break;
                        case"Arandommin":element.value=_NUMBERS.rand.min.toString(_CURRENT_BASE);break;
                        case"Arandommax":element.value=_NUMBERS.rand.max.toString(_CURRENT_BASE);break;
                        case"Amapmin1":element.value=_NUMBERS.map.min1.toString(_CURRENT_BASE);break;
                        case"Amapmax1":element.value=_NUMBERS.map.max1.toString(_CURRENT_BASE);break;
                        case"Amapmin2":element.value=_NUMBERS.map.min2.toString(_CURRENT_BASE);break;
                        case"Amapmax2":element.value=_NUMBERS.map.max2.toString(_CURRENT_BASE);break;
                    }
                }
            }else{
                _error_html(`{InputError} reseted number entered because it was not in correct format for base ${_CURRENT_BASE==="braille"?"256(braille)":_CURRENT_BASE}`);
                switch(element.id){
                    case"number_a":element.value=_NUMBERS.a.toString(_CURRENT_BASE);break;
                    case"number_b":element.value=_NUMBERS.b.toString(_CURRENT_BASE);break;
                    case"Arandommin":element.value=_NUMBERS.rand.min.toString(_CURRENT_BASE);break;
                    case"Arandommax":element.value=_NUMBERS.rand.max.toString(_CURRENT_BASE);break;
                    case"Amapmin1":element.value=_NUMBERS.map.min1.toString(_CURRENT_BASE);break;
                    case"Amapmax1":element.value=_NUMBERS.map.max1.toString(_CURRENT_BASE);break;
                    case"Amapmin2":element.value=_NUMBERS.map.min2.toString(_CURRENT_BASE);break;
                    case"Amapmax2":element.value=_NUMBERS.map.max2.toString(_CURRENT_BASE);break;
                }
            }
        }
        // TODO functions for _NUMBERS.mem;
    </script>
</head>
<body>
    <div id="box">
        <h1>big integer calculator</h1>
        <div id="border">
            <div data-content="base_chooser" title="base of the numbers for calculation (visually)">
                <label for="base_chooser">Numerical Base:</label>
                <select id="base_chooser">
                    <option disabled>Select Base</option>
                    <option value="2">binary (2)</option>
                    <option value="4">quaternary (4)</option>
                    <option value="8">octal (8)</option>
                    <option value="10" selected>decimal (10)</option>
                    <option value="16">hexadecimal (16)</option>
                    <option value="36">bin-text (36)</option>
                    <option value="256">byte (256)</option>
                    <option value="braille">braille-pattern (256)</option>
                </select>
            </div>
            <div data-content="memory_size" title="maximum length of each number in memory (! resets numbers if they are to large !)">
                <label for="memory_size">max memory:</label>
                <select id="memory_size">
                    <option disabled>Select memory size</option>
                    <option value="500" selected>500 Byte</option>
                    <option value="1000">1 Kilo Byte</option>
                    <option value="5000">5 Kilo Byte</option>
                    <option value="10000">10 Kilo Byte</option>
                    <option value="50000">50 Kilo Byte</option>
                    <option value="100000">100 Kilo Byte</option>
                    <option value="500000">500 Kilo Byte</option>
                    <option value="1000000">1 Mega Byte</option>
                    <option value="1048576">1 Mebi Byte</option>
                </select>
            </div>
            <div data-content="number_a">
                <label for="number_a" title="[A] input a number for calculation">A <small>(this)</small></label>
                <textarea id="number_a" maxlength="2147483648" class="number" title="[A] input a number for calculation">1</textarea>
                <button id="AseqB" title="[A] set equal to B">=B</button>
                <button id="Aabs" title="set sign of A absolute">|A|</button>
                <button id="Aneg" title="negates the sign of A">-A</button>
                <button id="Ainc" title="increments A once">++</button>
                <button id="Adec" title="decrements A once">--</button>
                <button id="Adouble" title="doubles A">*2</button>
                <div class="button" data-content="Ahalf">
                    <button id="Ahalf" title="halfes A">/2</button>
                    <select class="rounding" title="rounding for [/2]">
                        <option disabled>rounding</option>
                        <option value="f">floored</option>
                        <option value="c" selected>ceiled</option>
                    </select>
                </div>
            </div>
            <div data-content="number_b">
                <label for="number_b" title="[B] input a number for calculation">B <small>(n)</small></label>
                <textarea id="number_b" maxlength="2147483648" class="number" title="[B] input a number for calculation">0</textarea>
                <button id="BseqA" title="[B] set equal to A">=A</button>
                <button id="Babs" title="set sign of B absolute">|B|</button>
                <button id="Bneg" title="negates the sign of B">-B</button>
                <button id="Binc" title="increments B once">++</button>
                <button id="Bdec" title="decrements B once">--</button>
                <button id="Bdouble" title="doubles B">*2</button>
                <div class="button" data-content="Bhalf">
                    <button id="Bhalf" title="halfes B">/2</button>
                    <select class="rounding" title="rounding for [/2]">
                        <option disabled>rounding</option>
                        <option value="f">floored</option>
                        <option value="c" selected>ceiled</option>
                    </select>
                </div>
            </div>
            <div data-content="function-buttons">
                <button id="AaddB" title="set A to: A plus B">A + = B</button>
                <button id="AsubB" title="set A to: A minus B">A - = B</button>
                <button id="AmulB" title="set A to: A times B">A * = B</button>
                <button id="ApowB" title="set A to: A to the power of B">A ** = B</button>
                <button id="switchAB" title="switches A and B">A &LeftArrowRightArrow; B</button>
                <div class="button" data-content="AdivB">
                    <button id="AdivB" title="set A to: A divided by B">A / = B</button>
                    <select class="rounding" title="rounding for [A / = B]">
                        <option disabled>rounding</option>
                        <option value="f">floored</option>
                        <option value="c">ceiled</option>
                        <option value="r" selected>rounded</option>
                    </select>
                </div>
                <div class="button" data-content="AmodB">
                    <button id="AmodB" title="set A to: A modulo B">A % = B</button>
                    <select class="type" title="type for [A % = B]">
                        <option disabled>type</option>
                        <option value="e" selected>euclidean</option>
                        <option value="t">truncated</option>
                        <option value="f">floored</option>
                        <option value="c">ceiled</option>
                        <option value="r">rounded</option>
                    </select>
                </div>
                <button id="bitAls" title="shifts the bits of A by set amount to the left">A &lt;&lt; = x</button>
                <input type="number" id="bitAls_x" min="0" max="9007199254740991" class="number" title="amount for [A &lt;&lt; = x]" value="1">
                <button id="bitArs" title="shifts the bits of A by set amount to the right">A &gt;&gt; = B</button>
                <input type="number" id="bitArs_x" min="0" max="9007199254740991" class="number" title="amount for [A &gt;&gt; = x]" value="1">
                <button id="gcdAB" title="set A to: greatest common divisor of A and B">GCD</button>
                <button id="bitnoA" title="applies logical NOT to A">! A</button>
                <button id="bitnoB" title="applies logical NOT to B">! B</button>
                <button id="bitAanB" title="applies logical AND to A and B">A & B</button>
                <button id="bitAorB" title="applies logical OR to A and B">A | B</button>
                <button id="bitAxoB" title="applies logical XOR to A and B">A ^ B</button>
                <div id="AtB" title="shows if A and B are even or odd and if one is greater than the other one and vice versa">A (even) == B (even)</div>
            </div>
            <div data-content="Arandom">
                <button id="Arandom" title="set A to a random number in set bounds">random number</button>
                <label for="Arandommin" title="set minimum number for random generator">minimum:</label>
                <textarea id="Arandommin" maxlength="2147483648" class="number" title="set minimum number for random generator">0</textarea>
                <label for="Arandommax" title="set maximum number for random generator">maximum:</label>
                <textarea id="Arandommax" maxlength="2147483648" class="number" title="set maximum number for random generator">1000000</textarea>
            </div>
            <div data-content="Amap">
                <button id="Amap" title="map A from set initial bounds to set final bounds">map range</button>
                <div class="button" data-content="Amaplimit">
                    <input type="checkbox" id="Amaplimit">
                    <label for="Amaplimit" title="limits the mapping from A to its final bounds (toggle)">limit</label>
                    &verbar;
                    <select class="rounding" title="rounding for [map range]">
                        <option disabled>rounding</option>
                        <option value="f">floored</option>
                        <option value="c">ceiled</option>
                        <option value="r" selected>rounded</option>
                    </select>
                </div>
                <label for="Amapmin1" title="set initial minimum for mapping">initial minimum:</label>
                <textarea id="Amapmin1" maxlength="2147483648" class="number" title="set initial minimum for mapping">0</textarea>
                <label for="Amapmax1" title="set initial maximum for mapping">initial maximum:</label>
                <textarea id="Amapmax1" maxlength="2147483648" class="number" title="set initial maximum for mapping">1000000</textarea>
                <label for="Amapmin2" title="set final minimum for mapping">final minimum:</label>
                <textarea id="Amapmin2" maxlength="2147483648" class="number" title="set final minimum for mapping">1000000</textarea>
                <label for="Amapmax2" title="set final maximum for mapping">final maximum:</label>
                <textarea id="Amapmax2" maxlength="2147483648" class="number" title="set final maximum for mapping">0</textarea>
            </div>
            <div data-content="saved_numbers">
                <!-- TODO -->[ WIP ]
            </div>
            <div data-content="error_output"><textarea id="error_output" title="displays errors when they occur" readonly></textarea></div>
        </div>
    </div>
    <div id="loader">
        <div>
            <svg width="100%" height="100%" viewBox="0 0 350 100">
                <title>please wait...</title>
                <rect x="0" y="0" width="100%" height="100%" style="fill: transparent;"/>
                <g style="overflow:hidden;text-anchor: middle;">
                    <defs>
                        <mask id="textMask"><text style="fill: white;" x="175" y="55">please wait...</text></mask>
                        <filter id="innerShadow" x="-15%" y="-15%" width="140%" height="140%">
                            <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>
                            <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur2"/>
                            <feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur3"/>
                            <feMerge result="blur">
                                <feMergeNode in="blur" mode="normal"/>
                                <feMergeNode in="blu2" mode="normal"/>
                                <feMergeNode in="blur3" mode="normal"/>
                            </feMerge>
                            <feOffset in="blur" dx="0.7" dy="0.7"/>
                        </filter>
                    </defs>
                    <g mask="url(#textMask)">
                        <rect x="0" y="0" width="350" height="75" style="fill: black;"/>
                        <text style="fill: #0f0f;filter: url(#innerShadow);" x="175" y="55">please wait...</text>
                    </g>
                </g>
            </svg>
        </div>
    </div>
    <script>
        // ## elements
        const base_chooser=document.getElementById("base_chooser"),
            memory_size=document.getElementById("memory_size"),
            number_a=document.getElementById("number_a"),
            AseqB=document.getElementById("AseqB"),Aabs=document.getElementById("Aabs"),Aneg=document.getElementById("Aneg"),Ainc=document.getElementById("Ainc"),Adec=document.getElementById("Adec"),Adouble=document.getElementById("Adouble"),Ahalf=document.getElementById("Ahalf"),Ahalf_round=document.body.querySelector("#Ahalf+select.rounding"),
            number_b=document.getElementById("number_b"),
            BseqA=document.getElementById("BseqA"),Babs=document.getElementById("Babs"),Bneg=document.getElementById("Bneg"),Binc=document.getElementById("Binc"),Bdec=document.getElementById("Bdec"),Bdouble=document.getElementById("Bdouble"),Bhalf=document.getElementById("Bhalf"),Bhalf_round=document.body.querySelector("#Bhalf+select.rounding"),
            AaddB=document.getElementById("AaddB"),AsubB=document.getElementById("AsubB"),AmulB=document.getElementById("AmulB"),ApowB=document.getElementById("ApowB"),switchAB=document.getElementById("switchAB"),
            AdivB=document.getElementById("AdivB"),AdivB_round=document.body.querySelector("#AdivB+select.rounding"),AmodB=document.getElementById("AmodB"),AmodB_type=document.body.querySelector("#AmodB+select.type"),
            bitAls=document.getElementById("bitAls"),bitAls_x=document.getElementById("bitAls_x"),gcdAB=document.getElementById("gcdAB"),
            bitArs=document.getElementById("bitArs"),bitArs_x=document.getElementById("bitArs_x"),
            bitnoA=document.getElementById("bitnoA"),bitnoB=document.getElementById("bitnoB"),bitAanB=document.getElementById("bitAanB"),bitAorB=document.getElementById("bitAorB"),bitAxoB=document.getElementById("bitAxoB"),
            AtB=document.getElementById("AtB"),
            error_output=document.getElementById("error_output"),
            Arandom=document.getElementById("Arandom"),
            Arandommin=document.getElementById("Arandommin"),Arandommax=document.getElementById("Arandommax"),
            Amap=document.getElementById("Amap"),Amap_round=document.body.querySelector("#Amap+div>select.rounding"),Amaplimit=document.getElementById("Amaplimit"),
            Amapmin1=document.getElementById("Amapmin1"),Amapmax1=document.getElementById("Amapmax1"),
            Amapmin2=document.getElementById("Amapmin2"),Amapmax2=document.getElementById("Amapmax2"),
            loader=document.getElementById("loader");
        _error_html("Errors may be displayed here...\ndouble click anywhere on the page (except here) to remove this message");
        AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
        try{//~ Test number to console
            console.log(
                "TEST NUMBER: %c %s",
                "background-color:#000;color:#0f0;font-family:consolas;font-size:2em;",
                BigIntType.HelloThere.toString("braille")
            );
        }catch(error){
            _error_html(`[TEST NUMBER] : {${error.name}} : \"${error.message}\"`);//~ show only recent message (on screen) and not the whole stack
            console.error(error);//~ but do log the whole error object to console
        }
        // ## event listeners
        document.addEventListener("dblclick",ev=>(ev.composedPath().every(v=>!Object.is(v,error_output)))?_error_html(""):null,{passive:true});
        switchAB.addEventListener("click",ev=>{[number_a.value,number_b.value]=[number_b.value,number_a.value];},{passive:true});
        base_chooser.addEventListener("change",ev=>{
            _CURRENT_BASE=base_chooser.value;
            number_a.value=_NUMBERS.a.toString(_CURRENT_BASE);
            number_b.value=_NUMBERS.b.toString(_CURRENT_BASE);
            Arandommin.value=_NUMBERS.rand.min.toString(_CURRENT_BASE);
            Arandommax.value=_NUMBERS.rand.max.toString(_CURRENT_BASE);
            Amapmin1.value=_NUMBERS.map.min1.toString(_CURRENT_BASE);
            Amapmax1.value=_NUMBERS.map.max1.toString(_CURRENT_BASE);
            Amapmin2.value=_NUMBERS.map.min2.toString(_CURRENT_BASE);
            Amapmax2.value=_NUMBERS.map.max2.toString(_CURRENT_BASE);
        },{passive:true});
        memory_size.addEventListener("change",ev=>{
            _CURRENT_MEM_SIZE=Number(memory_size.value);
            BigIntType.MAX_SIZE=_CURRENT_MEM_SIZE;
            /**@type {number} - counter for amount of reseted numbers*/
            let r=0;
            if(_NUMBERS.a.length>BigIntType.MAX_SIZE){
                _NUMBERS.a.setEqualTo(BigIntType.Zero);
                number_a.value=_NUMBERS.a.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.b.length>BigIntType.MAX_SIZE){
                _NUMBERS.b.setEqualTo(BigIntType.Zero);
                number_b.value=_NUMBERS.b.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.rand.min.length>BigIntType.MAX_SIZE){
                _NUMBERS.rand.min.setEqualTo(BigIntType.Zero);
                Arandommin.value=_NUMBERS.rand.min.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.rand.max.length>BigIntType.MAX_SIZE){
                _NUMBERS.rand.max.setEqualTo(BigIntType.Zero);
                Arandommax.value=_NUMBERS.rand.max.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.map.min1.length>BigIntType.MAX_SIZE){
                _NUMBERS.map.min1.setEqualTo(BigIntType.Zero);
                Amapmin1.value=_NUMBERS.map.min1.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.map.max1.length>BigIntType.MAX_SIZE){
                _NUMBERS.map.max1.setEqualTo(BigIntType.Zero);
                Amapmax1.value=_NUMBERS.map.max1.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.map.min2.length>BigIntType.MAX_SIZE){
                _NUMBERS.map.min2.setEqualTo(BigIntType.Zero);
                Amapmin2.value=_NUMBERS.map.min2.toString(_CURRENT_BASE);
                r++;
            }
            if(_NUMBERS.map.max2.length>BigIntType.MAX_SIZE){
                _NUMBERS.map.max2.setEqualTo(BigIntType.Zero);
                Amapmax2.value=_NUMBERS.map.max2.toString(_CURRENT_BASE);
                r++;
            }
            if(r>0){
                if(r===1){_error_html("{MemSizeError} reseted number because it was to large for selected memory size");}
                else{_error_html("{MemSizeError} reseted numbers because they where to large for selected memory size");}
            }
        },{passive:true});
        // ## numbers
        for(const _number of document.body.querySelectorAll("textarea.number")){
            _number.addEventListener("keydown",ev=>{
                if(ev.key==="Enter"){
                    ev.preventDefault();
                    ev.target.blur();
                }
            },{passive:false});
            _number.addEventListener("input",ev=>_numberInput(ev.target),{passive:true});
            _number.addEventListener("change",ev=>_numberChange(ev.target),{passive:true});
        }
        for(const _number of document.body.querySelectorAll("input.number")){
            _number.addEventListener("keydown",ev=>{
                if(ev.key==="Enter"){
                    ev.preventDefault();
                    ev.target.blur();
                }
            },{passive:false});
            _number.addEventListener("input",ev=>{
                if(/^0*$/.test(ev.target.value)){ev.target.value='0';}
                else if(ev.target.value.length>16||!Number.isSafeInteger(Number(ev.target.value))){ev.target.value=String(Number.MAX_SAFE_INTEGER);}
                else{ev.target.value=String(Number(ev.target.value));}
            },{passive:true});
        }
        // ## buttons
        // TODO → abort (button on loader) mid calculation !? abort promise ?!
        AseqB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.setEqualTo(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        BseqA.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.setEqualTo(_NUMBERS.a).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Aabs.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.abs().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Babs.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.abs().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Aneg.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.neg().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Bneg.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.neg().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Ainc.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.inc().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Binc.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.inc().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Adec.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.dec().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Bdec.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.dec().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Adouble.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.double().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Bdouble.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.double().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Ahalf.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.half(Ahalf_round.value).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Bhalf.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.half(Bhalf_round.value).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        AaddB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.add(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        AsubB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.sub(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        AmulB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.mul(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        AmodB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.modulo(_NUMBERS.b,AmodB_type.value).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        ApowB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.pow(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        AdivB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.div(_NUMBERS.b,AdivB_round.value).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitAls.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.bitShiftL(Number(bitAls_x.value)).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitArs.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.bitShiftR(Number(bitArs_x.value)).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        gcdAB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.setEqualTo(BigIntType.GCD(_NUMBERS.a,_NUMBERS.b)).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitnoA.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.bitNOT().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitnoB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.b.bitNOT().toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_b.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitAanB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.bitAND(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitAorB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.bitOR(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        bitAxoB.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.bitXOR(_NUMBERS.b).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Arandom.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.setEqualTo(BigIntType.randomInt(_NUMBERS.rand.min,_NUMBERS.rand.max)).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        Amap.addEventListener("click",ev=>{
            loader.style.display="";
            _error_html("");
            new Promise((resolve,reject)=>{
                try{resolve(_NUMBERS.a.mapRange(_NUMBERS.map.min1,_NUMBERS.map.max1,_NUMBERS.map.min2,_NUMBERS.map.max2,Amap_round.value,Amaplimit.checked).toString(_CURRENT_BASE));}
                catch(error){reject(error);}
            }).then(
                value=>{number_a.value=value;},
                error=>{
                    _error_html(`{${error.name}} : "${error.message}"`);
                    console.error(error);
                }
            ).finally(()=>{
                AtB.innerHTML=`A (${_NUMBERS.a.isEven()?"even":"odd"}) ${_NUMBERS.a.isGreaterThan(_NUMBERS.b)?'>':(_NUMBERS.a.isSmallerThan(_NUMBERS.b)?'<':"==")} B (${_NUMBERS.b.isEven()?"even":"odd"})`;
                loader.style.display="none";
            });
        },{passive:true});
        loader.style.display="none";
    </script>
</body>
</html>