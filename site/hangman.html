<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="[MAZ01001.github.io] A simple word guessing game">
    <meta name="author" content="MAZ01001">
    <link rel="apple-touch-icon" sizes="180x180" href="../img/apple-touch-icon.png">
    <link rel="icon" type="image/x-icon" href="../img/MAZ_logo.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../img/favicon-16x16.png">
    <link rel="manifest" href="../img/site.webmanifest">
    <link rel="mask-icon" href="../img/safari-pinned-tab.svg" color="#ff9900">
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="../img/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <title>Hangman</title>
    <style>
        ::-webkit-scrollbar{width:.8rem;height:.8rem;}
        ::-webkit-scrollbar-thumb:vertical:window-inactive{border-right-style:dashed;}
        ::-webkit-scrollbar-thumb:horizontal:window-inactive{border-bottom-style:dashed;}
        ::-webkit-scrollbar-thumb:vertical{
            background-color:#0000;
            border-right:.2rem solid #000F;
            border-radius:0;
        }
        ::-webkit-scrollbar-thumb:hover:vertical,
        :hover::-webkit-scrollbar-thumb:vertical{
            background-color:#000F;
            box-shadow:inset .4rem 0 .4rem 0 #0A0F;
            border:none;
            border-top-left-radius:1rem;
            border-bottom-left-radius:1rem;
        }
        ::-webkit-scrollbar-thumb:horizontal{
            background-color:#0000;
            border-bottom:.2rem solid #000F;
            border-radius:0;
        }
        ::-webkit-scrollbar-thumb:hover:horizontal,
        :hover::-webkit-scrollbar-thumb:horizontal{
            background-color:#000F;
            box-shadow:inset 0 .4rem .4rem 0 #0A0F;
            border:none;
            border-top-left-radius:1rem;
            border-top-right-radius:1rem;
        }
        ::-webkit-scrollbar-thumb:hover:vertical,
        :hover::-webkit-scrollbar-thumb:hover:vertical{box-shadow:inset .4rem 0 .4rem 0 #0F0F;}
        ::-webkit-scrollbar-thumb:hover:horizontal,
        :hover::-webkit-scrollbar-thumb:hover:horizontal{box-shadow:inset 0 .4rem .4rem 0 #0F0F;}
        ::-webkit-scrollbar-track,
        ::-webkit-scrollbar-track-piece,
        ::-webkit-scrollbar-corner{display:none;background-color:#0000;}
        body{
            background-color: #000;
            color: #0f0;
            padding: 0;
            margin: 0;
            overflow: visible;
            font-family: 'Times New Roman', Times, serif;
            font-size: large;
        }
        *{user-select: none;}
        ::selection{
            background-color: #F90;
            color: #000;
        }
        input[type="button"]{cursor: pointer;}
        dialog::backdrop{background-color: #0007;}
        dialog[open]{
            background-color: #444;
            color: #0F0;
            border-radius: 1rem;
            display: grid;
            gap: .7rem;
            place-items: safe center;
            place-content: safe center;
        }
        dialog input{
            background-color: #111;
            color: #0F0;
            border-color: #000;
            border-radius: .4rem;
        }
        dialog fieldset{
            background-color: #222;
            border-color: #222;
            border-radius: .5rem;
            padding: .6rem;
        }
        dialog#settingsMenu>label{
            background-color: #222;
            border: 2px groove #222;
            border-radius: .5rem;
            padding: .3rem .6rem;
        }
        dialog h2{margin: 0;}
        dialog fieldset>legend{cursor: help;}
        div#box{
            position: absolute;
            top: 50%;left: 50%;
            transform:translate(-50%, -50%);
            width: max-content;
            height: max-content;
            padding: 0 .5rem 1rem .5rem;
            max-width: calc(100vw - calc(1rem + 4px));
            max-height: calc(100vh - calc(1rem + 4px));
            overflow: overlay;
            background-color:#222;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 5px 5px 30px -5px #080;
            border: 2px outset #444;
            display: grid;
            gap: 3rem;
            place-items: safe center;
            place-content: safe center;
        }
        div#box>h1{grid-area: 1/1/2/2;}
        span#displayWord{
            grid-area: 2/1/4/2;
            min-width: 20rem;
            max-width: 60rem;
            max-height: 20rem;
            overflow-y: overlay;
            user-select: text;
        }
        span#displayWord>span{
            font-family: consolas, monospace;
            font-size: x-large;
            user-select: text;
            padding: 0 2px;
            word-break: break-all;
        }
        div#letterButtons{
            grid-area: 4/1/5/2;
            min-width: 20rem;
            max-width: 30rem;
            max-height: 20rem;
            overflow-y: overlay;
            display: flex;
            flex-wrap: wrap;
            gap: .3rem;
            place-items: safe center;
            place-content: safe center;
        }
        div#letterButtons>input{
            font-family: consolas, monospace;
            font-size: large;
            font-weight: bold;
            background-color: #000;
            border-radius: .5rem;
            color: #0F0;
        }
        div#letterButtons>input:disabled{
            background-color: #111;
            border-style: inset;
            color: #0A0;
            cursor: not-allowed;
        }
        span#timer{
            grid-area: 2/2/3/3;
            font-size: larger;
        }
        span#guesses{
            grid-area: 3/2/4/3;
            font-size: xx-large;
        }
        div#options{
            grid-area: 4/2/5/3;
            display: flex;
            gap: .5rem;
            flex-direction: column;
        }
        div#options>input{
            background-color: #111;
            color: #0F0;
            padding: .2rem .5rem;
            border-radius: .4rem;
        }
        div#settingsWordList{
            display: flex;
            flex-direction: column;
            min-height: 1rem;
            max-height: 7rem;
            overflow: overlay;
            margin: .3rem 0;
        }
        div#settingsWordList>div>input{float: right;}
        div#settingsWordList>div>span{
            display: inline-block;
            width: 10.8rem;
            overflow: overlay;
            user-select: text;
        }
        input#settingsCharInput,
        input#settingsWordInput{width: 10rem;}
        div#settingsCharList{
            display: flex;
            flex-wrap: wrap;
            gap: .3rem;
            min-height: 1rem;
            max-height: 7rem;
            max-width: 15rem;
            overflow: overlay;
            margin: .3rem 0;
        }
        div#settingsCharList>input{
            font-family: consolas, monospace;
            font-size: medium;
        }
        div#settingsCharList>input.unhide{background-color: #333;}
        dialog#settingsMenu>h2{grid-area: 1/1/2/3;}
        fieldset#settingsChar{grid-area: 2/1/3/2;}
        fieldset#settingsWord{grid-area: 2/2/3/3;}
        label[for="settingsCharRandomUnhide"]{grid-area: 3/1/4/2;}
        input#settingsCharRandomUnhide{width: 2.2rem;}
        label[for="settingsMaxFails"]{grid-area: 3/2/4/3;}
        input#settingsMaxFails{width: 4rem;}
        div#settingsClosing{grid-area: 4/1/5/3;}
        dialog#finMenu>h2{grid-area: 1/1/2/2;}
        dialog#finMenu>fieldset{
            grid-area: 2/1/3/2;
            line-height: 2rem;
            padding-top: 0;
            padding-bottom: 0;
        }
        dialog#finMenu>fieldset *:not(legend){user-select: text;}
        dialog#finMenu>input{grid-area: 3/1/4/2;}
        span#finWord,
        span#finWordGuess,
        span#finWordIni{
            display: inline-block;
            vertical-align: bottom;
            max-height: 5rem;
            overflow: overlay;
            font-size: larger;
            word-break: break-all;
        }
        span#finWordGuess>span,
        span#finWordIni>span{padding: 0 2px;}
        span#displayWord>span.locked,
        span#finWordGuess>span.locked,
        span#finWordIni>span.locked{color: #0A0;}
        span#displayWord>span.hidden,
        span#finWordGuess>span.hidden,
        span#finWordIni>span.hidden{color: #040;}
    </style>
    <script>
        //@ts-check
        //~ game logic (before DOM loads)
        /**
         * ## get the item at position {@linkcode index} in {@linkcode set}
         * @param {Set<any>} set - a {@linkcode Set} object
         * @param {number} index - a positive integer to seek the position of an item in {@linkcode set} (must be smaller than the size of {@linkcode set})
         * @returns {any} the item in {@linkcode set} at position {@linkcode index} (otherwise `undefined`)
         */
        const indexOfSet=(set,index)=>{
            "use strict";
            for(const item of set)
                if(--index<0)return item;
            return undefined;
        };
        const
            /** @type {Set<string>} list of all words (locale case inseneitive) */
            wordList=new Set([
                "Unguessable","Inexpensive","Paste","Neighbor","Knock",
                "Calculus","Stone","Pretending","Warning","Recognize",
                "Spongebob","Train","Impressive","Aromatic","Crazy",
                "Entertainer","Copycat","Dark","Closed","Mathmatics"
            ]),
            /** @type {Set<string>} list of all unique letters for guessing (locale uppercase) */
            keyboardLetters=new Set([
                "A","B","C","D","E","F","G","H","I","J",
                "K","L","M","N","O","P","Q","R","S","T",
                "U","V","W","X","Y","Z"
            ]),
            /** @type {Set<string>} list of all unique letters to always display (locale uppercase) */
            keyboardLettersAlt=new Set([
                ",",".","-"," "
            ]),
            /** @type {Set<string>} [settings] list of all words */
            confWordList=new Set(wordList),
            /** @type {Set<string>} [settings] list of all unique letters for guessing (locale uppercase) */
            confKeyboardLetters=new Set(keyboardLetters),
            /** @type {Set<string>} [settings] list of all unique letters to always display (locale uppercase) */
            confKeyboardLettersAlt=new Set(keyboardLettersAlt),
            /** @type {Set<string>} letters that are revealed at the start of the round (if any) */
            startLetters=new Set(),
            /** @type {boolean[]} guesses of the current word (same length as the current word) */
            guessWord=[];
        let
            /** @type {number} max allowed fails for each round */
            maxFails=8,
            /** @type {number} number of fails for each round */
            fails=0,
            /** @type {number} percentage of random letters to unhide at start of each round */
            rngUnhide=20,
            /** @type {number} timestamp at start of each round */
            startTime=Date.now(),
            /** @type {string} the current word to guess each round (from {@linkcode wordList}) */
            secretWord=indexOfSet(wordList,Math.floor(wordList.size*Math.random()));
        /** ## gets {@linkcode rngUnhide} % of random letters from current word ({@linkcode secretWord}) and add them to {@linkcode startLetters} (if any) */
        const setRngLetters=()=>{
            "use strict";
            //~ get unique letters from current word (locale uppercase)
            const wordLetters=(letterSet=>{
                "use strict";
                //~ remove letters that are also in keyboardLettersAlt
                for(const char of keyboardLettersAlt)letterSet.delete(char);
                return Array.from(letterSet);
            })(new Set(secretWord.toLocaleUpperCase()));
            //~ now remove some random letters and also add them to startLetters
            for(let i=Math.floor(wordLetters.length*rngUnhide*.01);i>0;i--){
                const letter=wordLetters.splice(Math.floor(wordLetters.length*Math.random()),1)[0];
                startLetters.add(letter);
            }
        };
        /**
         * ## guess a letter of the current word
         * @param {string} letter - a letter from {@linkcode keyboardLetters}
         * @returns {Set<number>} a set of indices of the current word ({@linkcode secretWord}) where the letters ({@linkcode letter}) are (if present)
         */
        const guess=letter=>{
            "use strict";
            const letterIndices=new Set(),
                word=secretWord.toLocaleUpperCase();
            for(let i=word.indexOf(letter);i>=0;i=word.indexOf(letter,i+1))letterIndices.add(i);
            return letterIndices;
        };
        /** ## resets the game values and rolls a new word from {@linkcode wordList} */
        const retry=()=>{
            "use strict";
            secretWord=indexOfSet(wordList,Math.floor(wordList.size*Math.random()));
            startLetters.clear();
            setRngLetters();
            const word=secretWord.toLocaleUpperCase();
            guessWord.length=secretWord.length;
            for(let i=0;i<guessWord.length;i++)guessWord[i]=keyboardLettersAlt.has(word[i])||startLetters.has(word[i]);
            fails=0;
            startTime=Date.now();
        };
        /**
         * ## format time for the timer
         * @param {number} time - the current timer value in seconds
         * @returns {string} time in format `[H:]mm:ss`
         */
        const formatTimer=time=>{
            "use strict";
            const hours=Math.floor(time/3600),
                min=~~(time/60)%60,
                sec=~~(time%60);
            if(hours>0)return`${hours.toString()}:${min.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
            return`${min.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
        };
    </script>
</head>
<body>
    <div id="box">
        <h1>Hangman</h1>
        <span id="displayWord">loading...</span>
        <span id="timer">--:--</span>
        <span id="guesses">-/-</span>
        <div id="letterButtons">loading...</div>
        <div id="options">
            <input type="button" value="New round" id="retryButton">
            <input type="button" value="Settings" id="settingsButton" autofocus>
        </div>
    </div>
    <dialog id="settingsMenu">
        <h2>Settings</h2>
        <fieldset id="settingsChar">
            <legend title="Letters for guessing (words in the word list must only have these characters)">Alphabet</legend>
            <div id="settingsCharList">Loading...</div>
            <div>
                <input type="text" id="settingsCharInput" maxlength="1" placeholder="Add a character" title="Add a new character to the list above (case insensitive)">
                <input type="button" id="settingsCharConfirm" value="+" title="Click to add the character to the list above">
                <input type="button" id="settingsCharConfirmAlt" value="[+]" title="Click to add the character to the list above (not for guessing - will always show)">
            </div>
        </fieldset>
        <fieldset id="settingsWord">
            <legend title="Word list for guessing (chooses a random word from this list) - case insensitive">Word list</legend>
            <div id="settingsWordList">Loading...</div>
            <div>
                <input type="text" id="settingsWordInput" spellcheck="true" placeholder="Add a word" title="Add a new word to the list above">
                <input type="button" id="settingsWordConfirm" value="+" title="Click to add the word to the list above">
            </div>
        </fieldset>
        <label for="settingsCharRandomUnhide" title="Percentage of letters of the guessing word to randomly unhide (for each round)">
            Randomly unhide
            <input type="number" value="1" min="0" max="99" step="1" id="settingsCharRandomUnhide">
            % of letters
        </label>
        <label for="settingsMaxFails" title="Maximum number of fails per round (-1 → never loose)">
            Max fails
            <input type="number" value="8" min="-1" step="1" id="settingsMaxFails">
        </label>
        <div id="settingsClosing">
            <!-- TODO add [export] save-button and [import] file-input-field to write/read settings to/from a file (encoded JSON object) {wordList,keyboardLetters,keyboardLettersAlt,maxFails,rngUnhide} -->
            <input type="button" id="settingsConfirm" value="OK" title="confirm changes and start a new round">
            <input type="button" id="settingsAbort" value="Abort" title="revert changes and close menu" autofocus>
        </div>
    </dialog>
    <dialog id="finMenu">
        <h2>Loading...</h2>
        <fieldset>
            <legend title="Statistics for the last round">Stats</legend>
            <div>Word: <span id="finWord">________</span></div>
            <div>Your guess: <span id="finWordGuess">________</span></div>
            <div>Initial word: <span id="finWordIni">________</span></div>
            <div>Time taken: <span id="finTime">--:--</span></div>
            <div>Failed guesses: <span id="finFails">-</span> of max <span id="finFailsMax">-</span></div>
        </fieldset>
        <input type="button" id="finAgain" value="Play again" autofocus>
    </dialog>
    <script>
        //~ DOM elements
        /** @type {HTMLSpanElement} the guessing word with `span` for each character (unguessed characters are `█` and use class `hidden` - unhidden characters use class `locked`) *///@ts-ignore element does exist in DOM
        const displayWord=document.getElementById("displayWord");
        /** @type {HTMLSpanElement} timer text element (use {@linkcode formatTimer} for dislaying time) *///@ts-ignore element does exist in DOM
        const timer=document.getElementById("timer");
        /** @type {HTMLSpanElement} text  to show the current and max fails in format `[current fails]/[max fails]` *///@ts-ignore element does exist in DOM
        const guesses=document.getElementById("guesses");
        /** @type {HTMLDivElement} the keyboard with `input[type=button]` for each character (after a character has been choosen the button gets deactivated) *///@ts-ignore element does exist in DOM
        const letterButtons=document.getElementById("letterButtons");
        /** @type {HTMLInputElement} the reset button to start a new round (use {@linkcode retry}) *///@ts-ignore element does exist in DOM
        const retryButton=document.getElementById("retryButton");
        /** @type {HTMLInputElement} button to open the {@linkcode settingsMenu} *///@ts-ignore element does exist in DOM
        const settingsButton=document.getElementById("settingsButton");

        /** @type {HTMLDialogElement} the settings menu element (use this to open or close dialog box) *///@ts-ignore element does exist in DOM
        const settingsMenu=document.getElementById("settingsMenu");
        /** @type {HTMLDivElement} the character list (list of `input[type=button]` and `input[type=button].unhide` elements for each character) *///@ts-ignore element does exist in DOM
        const settingsCharList=document.getElementById("settingsCharList");
        /** @type {HTMLInputElement} text input for adding characters to {@linkcode settingsCharList} *///@ts-ignore element does exist in DOM
        const settingsCharInput=document.getElementById("settingsCharInput");
        /** @type {HTMLInputElement} button to confirm adding a character from {@linkcode settingsCharInput} to {@linkcode settingsCharList} *///@ts-ignore element does exist in DOM
        const settingsCharConfirm=document.getElementById("settingsCharConfirm");
        /** @type {HTMLInputElement} button to confirm adding a character from {@linkcode settingsCharInput} to {@linkcode settingsCharList} (with the `unhide` class) *///@ts-ignore element does exist in DOM
        const settingsCharConfirmAlt=document.getElementById("settingsCharConfirmAlt");
        /** @type {HTMLDivElement} the word list (list of `span` and `input[type=button]` within a `div` for each word) *///@ts-ignore element does exist in DOM
        const settingsWordList=document.getElementById("settingsWordList");
        /** @type {HTMLInputElement} text input for adding words to {@linkcode settingsWordList} *///@ts-ignore element does exist in DOM
        const settingsWordInput=document.getElementById("settingsWordInput");
        /** @type {HTMLInputElement} button to confirm adding a word from {@linkcode settingsWordInput} to {@linkcode settingsWordList} *///@ts-ignore element does exist in DOM
        const settingsWordConfirm=document.getElementById("settingsWordConfirm");
        /** @type {HTMLInputElement} number input for getting the "random unhide letters by percentage" value *///@ts-ignore element does exist in DOM
        const settingsCharRandomUnhide=document.getElementById("settingsCharRandomUnhide");
        /** @type {HTMLInputElement} number input for getting the "max failed attemps" value *///@ts-ignore element does exist in DOM
        const settingsMaxFails=document.getElementById("settingsMaxFails");
        /** @type {HTMLInputElement} button to confirm set settings and close {@linkcode settingsMenu} *///@ts-ignore element does exist in DOM
        const settingsConfirm=document.getElementById("settingsConfirm");
        /** @type {HTMLInputElement} button to abort and revert set settings and close {@linkcode settingsMenu} *///@ts-ignore element does exist in DOM
        const settingsAbort=document.getElementById("settingsAbort");

        /** @type {HTMLDialogElement} the fin menu element (use this to open or close dialog box) *///@ts-ignore element does exist in DOM
        const finMenu=document.getElementById("finMenu");
        /** @type {HTMLHeadingElement} the h2 heading in {@linkcode finMenu} *///@ts-ignore element does exist in DOM
        const finMenuHeading=finMenu.querySelector("h2");
        /** @type {HTMLSpanElement} the word guessed {@linkcode displayWord} fully uncovered *///@ts-ignore element does exist in DOM
        const finWord=document.getElementById("finWord");
        /** @type {HTMLSpanElement} the word guessed {@linkcode displayWord} *///@ts-ignore element does exist in DOM
        const finWordGuess=document.getElementById("finWordGuess");
        /** @type {HTMLSpanElement} the word guessed {@linkcode displayWord} in its original state at the start of the round *///@ts-ignore element does exist in DOM
        const finWordIni=document.getElementById("finWordIni");
        /** @type {HTMLSpanElement} the time it took to guess the word (use {@linkcode formatTimer}) *///@ts-ignore element does exist in DOM
        const finTime=document.getElementById("finTime");
        /** @type {HTMLSpanElement} the total fails of this round *///@ts-ignore element does exist in DOM
        const finFails=document.getElementById("finFails");
        /** @type {HTMLSpanElement} the max fails allowed for this round *///@ts-ignore element does exist in DOM
        const finFailsMax=document.getElementById("finFailsMax");
        /** @type {HTMLInputElement} button to close the {@linkcode finMenu} and start a new round *///@ts-ignore element does exist in DOM
        const finAgain=document.getElementById("finAgain");

        //~ game logic (after DOM loaded and elements exist as variables)
        /**
         * ## Ends the rund by showing the {@linkcode finMenu}
         * @param {boolean} win - `true` if this round was won and `false` if lost
         */
        const endRound=win=>{
            finTime.textContent=formatTimer((Date.now()-startTime)*.001);
            finMenuHeading.textContent=win?"Congratulations":"Game over";
            finWord.textContent=secretWord;
            finWordGuess.replaceChildren(...secretWord.split("").map((v,i)=>{
                "use strict";
                const V=v.toLocaleUpperCase(),
                    isLocked=keyboardLettersAlt.has(V)||startLetters.has(V),
                    txt=document.createElement("span");
                if(!isLocked&&guessWord[i]){
                    txt.textContent=v;
                    return txt;
                }
                txt.textContent=isLocked?v:"█";
                txt.classList.add(isLocked?"locked":"hidden");
                return txt;
            }));
            finWordIni.replaceChildren(...secretWord.split("").map((v,i)=>{
                "use strict";
                const V=v.toLocaleUpperCase(),
                    isLocked=keyboardLettersAlt.has(V)||startLetters.has(V),
                    txt=document.createElement("span");
                txt.textContent=isLocked?v:"█";
                txt.classList.add(isLocked?"locked":"hidden");
                return txt;
            }));
            finFails.textContent=fails.toString();
            finFailsMax.textContent=maxFails.toString();
            finMenu.showModal();
        };
        /** ## functione for when clicking on a letter for guessing */
        const letterClick=letter=>{
            "use strict";
            const guessIndices=guess(letter);
            if(guessIndices.size===0){
                if(++fails>=maxFails)endRound(false);
                updateFails();
                return;
            }
            for(let i=0;i<guessWord.length;i++)
                if(guessIndices.has(i))guessWord[i]=true;
            if(guessWord.every(v=>v))endRound(true);
            updateWord();
        }
        /** ## updates {@linkcode displayWord} with current settings ({@linkcode guessWord}) */
        const updateWord=()=>{
            "use strict";
            displayWord.replaceChildren(...secretWord.split("").map((v,i)=>{
                "use strict";
                const txt=document.createElement("span"),
                    V=v.toLocaleUpperCase();
                if(keyboardLettersAlt.has(V)||startLetters.has(V)){
                    txt.textContent=v;
                    txt.classList.add("locked");
                }else if(!guessWord[i]){
                    txt.textContent="█";
                    txt.classList.add("hidden");
                }else txt.textContent=v;
                return txt;
            }));
        };
        /** ## updates the {@linkcode guesses} value */
        const updateFails=()=>{
            "use strict";
            guesses.textContent=`${fails}/${maxFails}`;
            if(fails/maxFails<.3)guesses.style.color="";
            else if(fails/maxFails<.5)guesses.style.color="#F90";
            else guesses.style.color="#F22";
        };
        /** ## updates the keyboard with current settings ({@linkcode keyboardLetters} and {@linkcode startLetters}) */
        const updateKeyboard=()=>{
            "use strict";
            letterButtons.replaceChildren(...Array.from(keyboardLetters).map(v=>{
                "use strict";
                const letter=document.createElement("input");
                letter.type="button";
                letter.value=v;
                if(startLetters.has(v))letter.disabled=true;
                else letter.addEventListener("click",()=>{
                    "use strict";
                    letter.disabled=true;
                    letterClick(letter.value);
                },{passive:true,once:true});
                return letter;
            }));
        };

        /**
         * ## removes all words from {@linkcode settingsWordList} and {@linkcode confWordList} that contain {@linkcode char}
         * @param {string} char - a letter from the "Alphabet"
         */
        const removeWordsWithChar=char=>{
            "use strict";
            for(const container of settingsWordList.childNodes)
                if(container?.firstChild?.textContent?.toLocaleUpperCase()?.includes(char)??false)
                    container.remove();
            for(const word of confWordList)
                if(word.toLocaleUpperCase().includes(char))confWordList.delete(word);
        }
        /**
         * ## adds {@linkcode char} to {@linkcode confKeyboardLetters} and as button to {@linkcode settingsCharList} (incl. event listener for removal)
         * @param {string} char - a single letter for the "Alphabet"
         * @param {boolean} alt - if `true` uses {@linkcode confKeyboardLettersAlt} instead and adds class "unhide" to button
         */
        const settingsAddChar=(char,alt)=>{
            "use strict";
            const letter=document.createElement("input");
            letter.type="button";
            letter.value=char;
            settingsCharList.insertBefore(letter,settingsCharList.firstChild);
            if(alt){
                letter.title="(This character will always show) Click to remove this character and all words containing it";
                letter.classList.add("unhide");
                confKeyboardLettersAlt.add(char);
                letter.addEventListener("click",()=>{
                    "use strict";
                    confKeyboardLettersAlt.delete(char);
                    removeWordsWithChar(char);
                    letter.remove();
                },{passive:true,once:true});
            }else{
                letter.title="Click to remove this character and all words containing it";
                confKeyboardLetters.add(char);
                letter.addEventListener("click",()=>{
                    "use strict";
                    confKeyboardLetters.delete(char);
                    removeWordsWithChar(char);
                    letter.remove();
                },{passive:true,once:true});
            }
        }
        /**
         * ## adds {@linkcode word} to {@linkcode confWordList} and {@linkcode settingsWordList} (with a button to remove)
         * @param {string} word - a word for the guessing words list
         */
        const settingsAddWord=word=>{
            "use strict";
            confWordList.add(word);
            const container=document.createElement("div"),
                txt=document.createElement("span"),
                btn=document.createElement("input");
            txt.textContent=word;
            btn.type="button";
            btn.value="x";
            btn.title="Click to remove this word from the list";
            container.append(txt,btn);
            settingsWordList.insertBefore(container,settingsWordList.firstChild);
            btn.addEventListener("click",()=>{
                "use strict";
                confWordList.delete(word);
                container.remove();
            },{passive:true,once:true});
        }

        //~ add all event listeners
        let timerInterval=setInterval(()=>timer.textContent=formatTimer((Date.now()-startTime)*.001),300);
        document.body.addEventListener("mousedown",()=>document.getSelection()?.empty(),{passive:true});
        document.body.addEventListener("keypress",ev=>{
            if(settingsMenu.open||finMenu.open)return;
            const key=ev.key.toLocaleUpperCase();
            if(keyboardLetters.has(key)){
                ev.preventDefault();
                for(const letter of letterButtons.children)
                    if(letter instanceof HTMLInputElement&&letter.value===key){
                        letter.click();
                        break;
                    }
            }
        },{passive:false});

        retryButton.addEventListener("click",()=>{
            "use strict";
            retry();
            updateKeyboard();
            updateWord();
            updateFails();
        },{passive:true});
        settingsButton.addEventListener("click",()=>{
            "use strict";
            settingsCharList.replaceChildren();
            confKeyboardLetters.clear();
            for(const letter of keyboardLetters)settingsAddChar(letter,false);
            confKeyboardLettersAlt.clear();
            for(const letter of keyboardLettersAlt)settingsAddChar(letter,true);
            settingsWordList.replaceChildren();
            confWordList.clear();
            for(const word of wordList)settingsAddWord(word);
            settingsCharRandomUnhide.value=rngUnhide.toString();
            settingsMaxFails.value=maxFails.toString();
            settingsMenu.showModal();
        },{passive:true});

        settingsCharInput.addEventListener("input",()=>{
            "use strict";
            settingsCharInput.setCustomValidity("");
            const char=settingsCharInput.value.toLocaleUpperCase();
            if(char.length>1){
                settingsCharInput.setCustomValidity("Can only be one character");
                return;
            }
            if(confKeyboardLetters.has(char))settingsCharInput.setCustomValidity("Character already exist in list");
        },{passive:true});
        settingsCharConfirm.addEventListener("click",()=>{
            "use strict";
            if(!settingsCharInput.reportValidity())return;
            settingsAddChar(settingsCharInput.value,false);
            settingsCharInput.value="";
        },{passive:true});
        settingsCharConfirmAlt.addEventListener("click",()=>{
            "use strict";
            if(!settingsCharInput.reportValidity())return;
            settingsAddChar(settingsCharInput.value,true);
            settingsCharInput.value="";
        },{passive:true});
        settingsWordInput.addEventListener("input",()=>{
            "use strict";
            settingsWordInput.setCustomValidity("");
            const word=settingsWordInput.value.toLocaleUpperCase();
            for(const char of word){
                if(confKeyboardLetters.has(char))continue;
                settingsWordInput.setCustomValidity("Can only contain characters from the Alphabet list");
                break;
            }
        },{passive:true});
        settingsWordConfirm.addEventListener("click",()=>{
            "use strict";
            if(!settingsWordInput.reportValidity())return;
            settingsAddWord(settingsWordInput.value);
            settingsWordInput.value="";
        },{passive:true});
        settingsCharRandomUnhide.addEventListener("input",()=>{
            "use strict";
            settingsCharRandomUnhide.setCustomValidity("");
            if(!/^(0|[1-9][0-9]?)(\.[0-9]+)?$/.test(settingsCharRandomUnhide.value))settingsCharRandomUnhide.setCustomValidity("Must be a number from 0 to 99");
        },{passive:true});
        settingsMaxFails.addEventListener("input",()=>{
            "use strict";
            settingsMaxFails.setCustomValidity("");
            if(!/^(-1|0|[1-9][0-9]*)$/.test(settingsMaxFails.value))settingsMaxFails.setCustomValidity("Must be a whole number, larger or equal to -1");
        },{passive:true});
        settingsAbort.addEventListener("click",()=>{
            "use strict";
            settingsCharList.replaceChildren();
            confKeyboardLetters.clear();
            for(const letter of keyboardLetters)settingsAddChar(letter,false);
            confKeyboardLettersAlt.clear();
            for(const letter of keyboardLettersAlt)settingsAddChar(letter,true);
            confWordList.clear();
            for(const word of wordList)settingsAddWord(word);
            settingsCharRandomUnhide.value=rngUnhide.toString();
            settingsMaxFails.value=maxFails.toString();
            settingsMenu.close();
        },{passive:true});
        settingsConfirm.addEventListener("click",()=>{
            "use strict";
            if(!settingsCharRandomUnhide.reportValidity())return;
            if(!settingsMaxFails.reportValidity())return;
            keyboardLetters.clear();
            for(const letter of confKeyboardLetters)keyboardLetters.add(letter);
            keyboardLettersAlt.clear();
            for(const letter of confKeyboardLettersAlt)keyboardLettersAlt.add(letter);
            wordList.clear();
            for(const word of confWordList)wordList.add(word);
            rngUnhide=Number(settingsCharRandomUnhide.value);
            maxFails=Number(settingsMaxFails.value);
            settingsMenu.close();
            retry();
            updateKeyboard();
            updateWord();
            updateFails();
        },{passive:true});

        finAgain.addEventListener("click",()=>{
            "use strict";
            finMenu.close();
            retry();
            updateKeyboard();
            updateWord();
            updateFails();
        },{passive:true});

        //~ start the game
        retry();
        updateKeyboard();
        updateWord();
        updateFails();
    </script>
</body>
</html>
