<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="[MAZ01001.github.io] A simple word guessing game">
    <meta name="author" content="MAZ01001">
    <link rel="apple-touch-icon" sizes="180x180" href="../img/apple-touch-icon.png">
    <link rel="icon" type="image/x-icon" href="../img/MAZ_logo.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../img/favicon-16x16.png">
    <link rel="manifest" href="../img/site.webmanifest">
    <link rel="mask-icon" href="../img/safari-pinned-tab.svg" color="#ff9900">
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="../img/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <title>Hangman</title>
    <style>
        @supports not selector(::-webkit-scrollbar){
            *{
                scrollbar-width: thin;
                scrollbar-color: #0A07 transparent;
            }
            *:hover{scrollbar-color: #0A0 transparent;}
        }
        ::-webkit-scrollbar{
            width:.8rem;
            height:.8rem;
        }
        ::-webkit-scrollbar-thumb:vertical:window-inactive{border-right-style:dashed;}
        ::-webkit-scrollbar-thumb:horizontal:window-inactive{border-bottom-style:dashed;}
        ::-webkit-scrollbar-thumb:vertical{
            background-color:transparent;
            border-right:.3rem solid #0A0;
            border-radius:0;
        }
        :hover::-webkit-scrollbar-thumb:vertical{
            background-color:#000;
            box-shadow:inset .4rem 0 .4rem 0 #0A0;
            border:none;
            border-top-left-radius:1rem;
            border-bottom-left-radius:1rem;
        }
        ::-webkit-scrollbar-thumb:horizontal{
            background-color:transparent;
            border-bottom:.3rem solid #0A0;
            border-radius:0;
        }
        :hover::-webkit-scrollbar-thumb:horizontal{
            background-color:#000;
            box-shadow:inset 0 .4rem .4rem 0 #0A0;
            border:none;
            border-top-left-radius:1rem;
            border-top-right-radius:1rem;
        }
        ::-webkit-scrollbar-thumb:hover:vertical{box-shadow:inset .4rem 0 .4rem 0 #0F0;}
        ::-webkit-scrollbar-thumb:hover:horizontal{box-shadow:inset 0 .4rem .4rem 0 #0F0;}
        ::-webkit-scrollbar-track,
        ::-webkit-scrollbar-track-piece,
        ::-webkit-scrollbar-button,
        ::-webkit-scrollbar-corner{
            display:none;
            background-color:transparent;
        }
        body{
            background-color: #000;
            color: #0f0;
            padding: 0;
            margin: 0;
            overflow: hidden;
            font-family: 'Times New Roman', Times, serif;
            font-size: large;
        }
        *{user-select: none;}
        ::selection{
            background-color: #F90;
            color: #000;
        }
        *:focus,
        input#settingsCharAlt:focus+
        label[for="settingsCharAlt"]{
            outline: 1px solid #F90;
            outline-offset: -1px;
        }
        input:not(:disabled):hover,
        select:not(:disabled):hover,
        input#settingsCharAlt:hover+
        label[for="settingsCharAlt"]{
            outline: 1px solid #0A0;
            outline-offset: -1px;
        }
        input[type="button"],
        input[type="checkbox"],
        select{cursor: pointer;}
        input:disabled,
        select:disabled{cursor: not-allowed;}
        select{
            background-color: #111;
            color: #0F0;
            border: 2px outset #000;
            border-radius: .4rem;
        }
        dialog::backdrop{background-color: #0007;}
        dialog[open]{
            background-color: #444;
            color: #0F0;
            border-radius: 1rem;
            display: grid;
            gap: .7rem;
            place-items: safe center;
            place-content: safe center;
            overflow: auto;
            scrollbar-gutter: stable both-edges;
        }
        dialog input{
            background-color: #111;
            color: #0F0;
            border-color: #000;
            border-radius: .4rem;
        }
        dialog fieldset{
            background-color: #222;
            border-color: #222;
            border-radius: .5rem;
            padding: .6rem;
        }
        dialog#settingsMenu>label{
            background-color: #222;
            border: 2px groove #222;
            border-radius: .5rem;
            padding: .3rem .6rem;
        }
        dialog h2{margin: 0;}
        dialog fieldset>legend{cursor: help;}
        div#box{
            position: absolute;
            top: 50%;left: 50%;
            transform:translate(-50%, -50%);
            width: max-content;
            height: max-content;
            padding: 0 .5rem 1rem .5rem;
            max-width: calc(100vw - calc(1rem + 4px));
            max-height: calc(100vh - calc(1rem + 4px));
            overflow: auto;
            scrollbar-gutter: stable both-edges;
            background-color:#222;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 5px 5px 30px -5px #080;
            border: 2px outset #444;
            display: grid;
            gap: 3rem;
            place-items: safe center;
            place-content: safe center;
        }
        div#box>h1{grid-area: 1/1/2/2;}
        span#displayWord{
            grid-area: 2/1/4/2;
            min-width: 20rem;
            max-width: 60rem;
            max-height: 20rem;
            overflow-y: auto;
            scrollbar-gutter: stable both-edges;
            user-select: text;
        }
        span#displayWord>span{
            font-family: consolas, monospace;
            font-size: x-large;
            user-select: text;
            padding: 0 2px;
            word-break: break-all;
        }
        div#letterButtons{
            grid-area: 4/1/5/2;
            min-width: 20rem;
            max-width: 30rem;
            max-height: 20rem;
            overflow-y: auto;
            scrollbar-gutter: stable both-edges;
            display: flex;
            flex-wrap: wrap;
            gap: .3rem;
            place-items: safe center;
            place-content: safe center;
        }
        div#letterButtons>input{
            font-family: consolas, monospace;
            font-size: large;
            font-weight: bold;
            background-color: #000;
            border-radius: .5rem;
            color: #0F0;
        }
        div#letterButtons>input:disabled{
            background-color: #111;
            border-style: inset;
            color: #0A0;
        }
        span#timer{
            grid-area: 2/2/3/3;
            font-size: larger;
        }
        span#guesses{
            grid-area: 3/2/4/3;
            font-size: xx-large;
        }
        div#options{
            grid-area: 4/2/5/3;
            display: flex;
            gap: .5rem;
            flex-direction: column;
        }
        div#options>input{
            background-color: #111;
            color: #0F0;
            padding: .2rem .5rem;
            border-radius: .4rem;
        }
        div#settingsWordList,
        div#importViewWordList{
            display: flex;
            flex-direction: column;
            min-height: 1rem;
            max-height: 10rem;
            overflow: auto;
            scrollbar-gutter: stable both-edges;
            margin: .3rem 0;
        }
        div#settingsWordList>div>input{float: right;}
        div#settingsWordList>div>span,
        div#importViewWordList>div>span{
            display: inline-block;
            width: 9rem;
            overflow: auto;
            scrollbar-gutter: stable both-edges;
            user-select: text;
        }
        div#importViewWordList>div>span{white-space: pre;}
        input#settingsCharInput,
        input#settingsWordInput{width: 10rem;}
        label[for="settingsCharAlt"]{
            background-color: #111;
            border: 2px outset #000;
            border-radius: .4rem;
            padding: 0 .3rem;
            color: #0A0;
        }
        input#settingsCharAlt{
            width: 0;
            margin: 0;
        }
        input#settingsCharAlt:checked+
        label[for="settingsCharAlt"]{
            background-color: #222;
            border-style: inset;
            color: #0F0;
        }
        div#settingsCharList,
        div#importViewCharList{
            display: flex;
            flex-wrap: wrap;
            gap: .3rem;
            min-height: 1.5rem;
            max-height: 10rem;
            max-width: 13.5rem;
            overflow: auto;
            scrollbar-gutter: stable both-edges;
            margin: .3rem 0;
        }
        div#settingsCharList>input{
            font-family: consolas, monospace;
            font-size: medium;
        }
        div#importViewCharList>span{
            background-color: #000;
            border: 2px outset #000;
            border-radius: .4rem;
            font-family: consolas, monospace;
            font-size: medium;
            padding: 0 .3rem;
            user-select: text;
            white-space: pre;
        }
        div#settingsCharList>input.unhide,
        div#importViewCharList>span.unhide{background-color: #333;}
        dialog#settingsMenu>h2{grid-area: 1/1/2/3;}
        fieldset#settingsChar{grid-area: 2/1/3/2;}
        fieldset#settingsWord{grid-area: 2/2/3/3;}
        label[for="settingsCharRandomUnhide"]{grid-area: 3/1/4/2;}
        input#settingsCharRandomUnhide{width: 2.2rem;}
        label[for="settingsMaxFails"]{grid-area: 3/2/4/3;}
        input#settingsMaxFails{width: 4rem;}
        div#settingsClosing{grid-area: 4/1/5/3;}
        dialog#finMenu>h2{grid-area: 1/1/2/2;}
        dialog#finMenu>fieldset{
            grid-area: 2/1/3/2;
            line-height: 2rem;
            padding-top: 0;
            padding-bottom: 0;
        }
        dialog#finMenu>fieldset *:not(legend){user-select: text;}
        dialog#finMenu>input{grid-area: 3/1/4/2;}
        span#finWord,
        span#finWordGuess,
        span#finWordIni,
        span#finGuesses{
            display: inline-block;
            vertical-align: bottom;
            max-height: 5rem;
            overflow: auto;
            scrollbar-gutter: stable both-edges;
            font-size: larger;
            word-break: break-all;
        }
        span#finWordGuess>span,
        span#finWordIni>span,
        span#finGuesses>span{padding: 0 2px;}
        span#displayWord>span.locked,
        span#finWordGuess>span.locked,
        span#finWordIni>span.locked{color: #0A0;}
        span#displayWord>span.hidden,
        span#finWordGuess>span.hidden,
        span#finWordIni>span.hidden{color: #040;}
        span#finGuesses>span.fail{color: #F44;}
        dialog#importMenu>fieldset:first-of-type{background-color: #111;}
        fieldset#importDataView>div{
            display: grid;
            gap: .7rem;
            place-items: safe center;
            place-content: safe center;
            grid-template-columns: auto auto;
        }
        fieldset#importDataView>div>span{
            background-color: #222;
            border: 2px groove #222;
            border-radius: .5rem;
            padding: .3rem .6rem;
        }
        fieldset#importDataView>div>span:last-of-type{grid-area: 3/1/4/3;}
        fieldset#importDataOptions>div{
            display: grid;
            grid-template-columns: auto auto;
            gap: .4rem;
        }
        dialog#importMenu.blocked>fieldset:not(:first-of-type),
        dialog#importMenu.blocked>div>input#importConfirm{filter: brightness(.5) saturate(0);}
    </style>
    <script>
        //@ts-check
        //~ game logic (before DOM loads)
        /**
         * ## get a random item from {@linkcode set}
         * @param {Set<any>} set - a {@linkcode Set} object
         * @returns {any} a random item from {@linkcode set}
         */
        const randomOfSet=set=>{
            "use strict";
            let index=Math.floor(set.size*Math.random());
            for(const item of set)
                if(--index<0)return item;
            return set.values().next().value;
        };
        const
            /** @type {string} prefix for {@linkcode window.localStorage} */
            storagePrefix="HangmanGameSettings_",
            /** @type {RegExp} RegExp matching each (combined) unicode symbol/character/emoji consecutively */
            unicodeRegExp=/(?:\p{Extended_Pictographic}[\p{Emoji_Modifier}\p{M}]*(?:\p{Join_Control}\p{Extended_Pictographic}[\p{Emoji_Modifier}\p{M}]*)*|\s|.)\p{M}*/guy,
            /** @type {RegExp} RegExp matching one (combined) unicode symbol/character/emoji (does not match an empty string) */
            unicodeRegExpSingle=/^(?:\p{Extended_Pictographic}[\p{Emoji_Modifier}\p{M}]*(?:\p{Join_Control}\p{Extended_Pictographic}[\p{Emoji_Modifier}\p{M}]*)*|\s|.)\p{M}*$/u,
            /** @type {Set<string>} list of all words (different capitalization) */
            wordList=new Set([
                "Unguessable","Inexpensive","Paste","Neighbor","Knock",
                "Calculus","Stone","Pretending","Warning","Recognize",
                "Spongebob","Train","Impressive","Aromatic","Crazy",
                "Entertainer","Copycat","Dark","Closed","Mathmatics"
            ]),
            /** @type {Set<string>} list of all unique letters for guessing (locale uppercase) */
            keyboardLetters=new Set([
                "A","B","C","D","E","F","G","H","I","J",
                "K","L","M","N","O","P","Q","R","S","T",
                "U","V","W","X","Y","Z"
            ]),
            /** @type {Set<string>} list of all unique letters to always display (locale uppercase) */
            keyboardLettersAlt=new Set([
                ",",".","-"," "
            ]),
            /** @type {Set<string>} letters that are revealed at the start of the round (if any - locale uppercase) */
            startLetters=new Set(),
            /** @type {Set<string>} letters guessed this round (locale uppercase) */
            guessLetters=new Set(),
            /** @type {Set<string>} [settings] list of all words (different capitalization) */
            confWordList=new Set(),
            /** @type {Set<string>} [settings] list of all unique letters for guessing (locale uppercase) */
            confKeyboardLetters=new Set(),
            /** @type {Set<string>} [settings] list of all unique letters to always display (locale uppercase) */
            confKeyboardLettersAlt=new Set(),
            /** @type {Set<string>} [import] letters guessed this round (locale uppercase) */
            importGuessLetters=new Set(),
            /** @type {Set<string>} [import] letters that where revealed at the start of this round (if any - locale uppercase) */
            importStartLetters=new Set(),
            /** @type {Set<string>} [import] list of all unique letters for guessing (locale uppercase) */
            importKeyboardLetters=new Set(),
            /** @type {Set<string>} [import] list of all unique letters to always display (locale uppercase) */
            importKeyboardLettersAlt=new Set(),
            /** @type {Set<string>} [import] list of all words (different capitalization) */
            importWordList=new Set();
        let
            /** @type {number} max allowed fails for each round */
            maxFails=8,
            /** @type {number} number of fails for each round */
            fails=0,
            /** @type {number} percentage of random letters to unhide at start of each round */
            rngUnhide=20,
            /** @type {number} timestamp at start of each round */
            startTime=NaN,
            /** @type {string} the current word to guess each round (from {@linkcode wordList}) */
            secretWord="",
            /** @type {number} [import] max allowed fails for each round */
            importMaxFails=NaN,
            /** @type {number} [import] number of fails for this round */
            importFails=NaN,
            /** @type {number} [import] percentage of random letters to unhide at start of this round */
            importRngUnhide=NaN,
            /** @type {number} [import] progress time in milliseconds */
            importTime=NaN,
            /** @type {string} [import] the current word to guess (must be present in final word list) */
            importSecretWord="";
        /** ## gets {@linkcode rngUnhide} % of random letters from current word ({@linkcode secretWord}) and add them to {@linkcode startLetters} (if any) */
        const setRngLetters=()=>{
            "use strict";
            //~ get unique letters from current word (locale uppercase)
            const wordLetters=(letterSet=>{
                "use strict";
                //~ remove letters that are also in keyboardLettersAlt
                for(const char of keyboardLettersAlt)letterSet.delete(char);
                return Array.from(letterSet);
            })(new Set(Array.from(secretWord.toLocaleUpperCase().matchAll(unicodeRegExp),v=>v[0])));
            //~ now remove some random letters and also add them to startLetters
            for(let i=Math.floor(wordLetters.length*rngUnhide*.01);i>0;i--)
                startLetters.add(wordLetters.splice(Math.floor(wordLetters.length*Math.random()),1)[0]);
        };
        /**
         * ## guess a letter of the current word
         * @param {string} letter - a letter from {@linkcode keyboardLetters}
         * @returns {Set<number>} a set of (unicode) indices of the current word ({@linkcode secretWord}) where the letters ({@linkcode letter}) are (if present)
         */
        const guess=letter=>{
            "use strict";
            const letterIndices=new Set();
            let index=0;
            for(const[char]of secretWord.toLocaleUpperCase().matchAll(unicodeRegExp)){
                if(char===letter)letterIndices.add(index);
                index++;
            }
            return letterIndices;
        };
        /** ## resets the game values and rolls a new word from {@linkcode wordList} */
        const retry=()=>{
            "use strict";
            secretWord=randomOfSet(wordList);
            startLetters.clear();
            setRngLetters();
            guessLetters.clear();
            fails=0;
            startTime=Date.now();
        };
        /**
         * ## format time for the timer
         * @param {number} time - the current timer value in milliseconds
         * @returns {string} time in format `[H:]mm:ss`
         */
        const formatTimer=time=>{
            "use strict";
            time*=.001;
            const hours=Math.floor(time/3600),
                min=~~(time/60)%60,
                sec=~~(time%60);
            if(hours>0)return`${hours.toString()}:${min.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
            return`${min.toString().padStart(2,"0")}:${sec.toString().padStart(2,"0")}`;
        };
        /** ## save current settings to file (UTF-8 JSON) */
        const saveToFile=()=>{
            "use strict";
            const blob=new Blob(
                [JSON.stringify({
                    "maxFails":maxFails,
                    "rngUnhide":rngUnhide,
                    "time":Date.now()-startTime,
                    "secretWord":secretWord,
                    "fails":fails,
                    "guessLetters":[...guessLetters],
                    "startLetters":[...startLetters],
                    "keyboardLetters":[...keyboardLetters],
                    "keyboardLettersAlt":[...keyboardLettersAlt],
                    "wordList":[...wordList],
                },null,4)],
                {type:"application/json;charset=UTF-8;"}
            );
            const link=document.createElement("a"),
                blobLink=URL.createObjectURL(blob);
            link.href=blobLink;
            link.download=`HangmanGameSettings-${Date.now()}.json`;
            link.click();
        };
        /**
         * ## validates and loads given parsed JSON data
         * - ignores charcters/words that do not match
         * - prioritizes characters over alternate characters
         * - only uses words that use characters from the character lists
         * - only overrides if data exists
         * @param {boolean} importVar - if `true` uses the `import*` variables otherwise the real ones
         * @param {any} _maxFails - parsed JSON data for {@linkcode maxFails} or `null` if not present
         * @param {any} _rngUnhide - parsed JSON data for {@linkcode rngUnhide} or `null` if not present
         * @param {any} _time - parsed JSON data for timer ({@linkcode startTime}) or `null` if not present
         * @param {any} _secretWord - parsed JSON data for {@linkcode secretWord} or `null` if not present
         * @param {any} _fails - parsed JSON data for {@linkcode fails} or `null` if not present
         * @param {any} _guessLetters - parsed JSON data for {@linkcode guessLetters} or `null` if not present
         * @param {any} _startLetters - parsed JSON data for {@linkcode startLetters} or `null` if not present
         * @param {any} _keyboardLetters - parsed JSON data for {@linkcode keyboardLetters} or `null` if not present
         * @param {any} _keyboardLettersAlt - parsed JSON data for {@linkcode keyboardLettersAlt} or `null` if not present
         * @param {any} _wordList - parsed JSON data for {@linkcode wordList} or `null` if not present
         * @throws {TypeError} if {@linkcode importVar} is not a boolean
         */
        const loadParsedJSON=(
            importVar,
            _maxFails,
            _rngUnhide,
            _time,
            _secretWord,
            _fails,
            _guessLetters,
            _startLetters,
            _keyboardLetters,
            _keyboardLettersAlt,
            _wordList,
        )=>{
            "use strict";
            if(typeof importVar!=="boolean")throw new TypeError("[loadParsedJSON] importVar is not a boolean");
            if(typeof _rngUnhide==="number"&&_rngUnhide>=0&&_rngUnhide<=99)importVar?importRngUnhide=_rngUnhide:rngUnhide=_rngUnhide;
            if(typeof _maxFails==="number"&&Number.isSafeInteger(_maxFails)&&_maxFails>=-1)importVar?importMaxFails=_maxFails:maxFails=_maxFails;
            if(_keyboardLetters!=null){
                if(Array.isArray(_keyboardLetters)&&_keyboardLetters.every(v=>typeof v==="string")){
                    for(let i=_keyboardLetters.length-1;i>=0;i--)
                        if(!unicodeRegExpSingle.test(_keyboardLetters[i]))_keyboardLetters.splice(i,1);
                    if(_keyboardLetters.length>0){
                        if(importVar){
                            importKeyboardLetters.clear();
                            for(const char of _keyboardLetters)importKeyboardLetters.add(char.toLocaleUpperCase());
                        }else{
                            keyboardLetters.clear();
                            for(const char of _keyboardLetters)keyboardLetters.add(char.toLocaleUpperCase());
                        }
                    }
                }
            }
            if(_keyboardLettersAlt!=null){
                if(Array.isArray(_keyboardLettersAlt)&&_keyboardLettersAlt.every(v=>typeof v==="string")){
                    for(let i=_keyboardLettersAlt.length-1;i>=0;i--)
                        if(
                            !unicodeRegExpSingle.test(_keyboardLettersAlt[i])
                            ||(
                                importVar?
                                importKeyboardLetters.has(_keyboardLettersAlt[i].toLocaleUpperCase()):
                                keyboardLetters.has(_keyboardLettersAlt[i].toLocaleUpperCase())
                            )
                        )_keyboardLettersAlt.splice(i,1);
                    if(_keyboardLettersAlt.length>0){
                        if(importVar){
                            importKeyboardLettersAlt.clear();
                            for(const char of _keyboardLettersAlt)importKeyboardLettersAlt.add(char.toLocaleUpperCase());
                        }else{
                            keyboardLettersAlt.clear();
                            for(const char of _keyboardLettersAlt)keyboardLettersAlt.add(char.toLocaleUpperCase());
                        }
                    }
                }
            }
            if(_wordList!=null){
                if(Array.isArray(_wordList)&&_wordList.every(v=>typeof v==="string")){
                    for(let i=_wordList.length-1;i>=0;i--)
                        for(const[char]of _wordList[i].matchAll(unicodeRegExp))
                            if(
                                importVar?
                                !(importKeyboardLetters.has(char.toLocaleUpperCase())||importKeyboardLettersAlt.has(char.toLocaleUpperCase())):
                                !(keyboardLetters.has(char.toLocaleUpperCase())||keyboardLettersAlt.has(char.toLocaleUpperCase()))
                            ){
                                _wordList.splice(i,1);
                                break;
                            }
                    if(_wordList.length>0){
                        if(importVar){
                            importWordList.clear();
                            for(const word of _wordList)importWordList.add(word);
                        }else{
                            wordList.clear();
                            for(const word of _wordList)wordList.add(word);
                        }
                    }
                }
            }
            //~ check saved round
            if(typeof _secretWord!=="string"||!(importVar?importWordList.has(_secretWord):wordList.has(_secretWord)))return;
            if(!Array.isArray(_guessLetters)||_guessLetters.some(v=>typeof v!=="string"||!(importVar?importKeyboardLetters.has(v):keyboardLetters.has(v))))return;
            if(!Array.isArray(_startLetters)||_startLetters.some(v=>typeof v!=="string"||!(importVar?importKeyboardLetters.has(v):keyboardLetters.has(v))))return;
            if(typeof _time!=="number"||!Number.isInteger(_time)||_time<0)return;
            if(typeof _fails!=="number"||!Number.isInteger(_fails)||_fails<0||(importVar?(importMaxFails!==-1&&_fails>importMaxFails):(maxFails!==-1&&_fails>maxFails)))return;
            if([..._secretWord.toLocaleUpperCase().matchAll(unicodeRegExp)].every(([v])=>
                _startLetters.includes(v)
                ||_guessLetters.includes(v)
                ||(importVar?importKeyboardLettersAlt.has(v):keyboardLettersAlt.has(v))
            ))return;
            //~ load saved round
            if(importVar){
                importFails=_fails;
                importTime=_time;
                importSecretWord=_secretWord;
                importStartLetters.clear();
                _startLetters.forEach(v=>importStartLetters.add(v));
                importGuessLetters.clear();
                _guessLetters.forEach(v=>importGuessLetters.add(v));
            }else{
                fails=_fails;
                startTime=Date.now()-_time;
                secretWord=_secretWord;
                startLetters.clear();
                _startLetters.forEach(v=>startLetters.add(v));
                guessLetters.clear();
                _guessLetters.forEach(v=>guessLetters.add(v));
            }
        }
        /**
         * ## [async] load previously saved settings from file (UTF-8 JSON)
         * loads values into `import*` variables
         * @param {File} file - a `HangmanGameSettings` JSON file (UTF-8)
         * @returns {Promise<boolean>} whether loading was successful or not
         */
        const loadFromFile=async file=>{
            "use strict";
            const text=await file.text().catch(()=>null);
            if(text==null)return false;
            const parsed=JSON.parse(text);
            if(parsed==null||!(parsed instanceof Object))return false;
            loadParsedJSON(
                true,
                parsed?.maxFails,
                parsed?.rngUnhide,
                parsed?.time,
                parsed?.secretWord,
                parsed?.fails,
                parsed?.guessLetters,
                parsed?.startLetters,
                parsed?.keyboardLetters,
                parsed?.keyboardLettersAlt,
                parsed?.wordList,
            );
            return true;
        };
        /** ## saves current settings to {@linkcode window.localStorage} */
        const updateLocalStorage=()=>{
            "use strict";
            window.localStorage.setItem(`${storagePrefix}maxFails`,JSON.stringify(maxFails));
            window.localStorage.setItem(`${storagePrefix}rngUnhide`,JSON.stringify(rngUnhide));
            window.localStorage.setItem(`${storagePrefix}time`,JSON.stringify(Date.now()-startTime));
            window.localStorage.setItem(`${storagePrefix}secretWord`,JSON.stringify(secretWord));
            window.localStorage.setItem(`${storagePrefix}fails`,JSON.stringify(fails));
            window.localStorage.setItem(`${storagePrefix}guessLetters`,JSON.stringify([...guessLetters]));
            window.localStorage.setItem(`${storagePrefix}startLetters`,JSON.stringify([...startLetters]));
            window.localStorage.setItem(`${storagePrefix}keyboardLetters`,JSON.stringify([...keyboardLetters]));
            window.localStorage.setItem(`${storagePrefix}keyboardLettersAlt`,JSON.stringify([...keyboardLettersAlt]));
            window.localStorage.setItem(`${storagePrefix}wordList`,JSON.stringify([...wordList]));
        };
        /** ## removes all stored data from {@linkcode window.localStorage} */
        const clearLocalStorage=()=>{
            "use strict";
            for(const key in window.localStorage)
                if(key.startsWith(storagePrefix))window.localStorage.removeItem(key);
        };
        //~ load settings from `window.localStorage`
        loadParsedJSON(
            false,
            JSON.parse(window.localStorage.getItem(`${storagePrefix}maxFails`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}rngUnhide`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}time`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}secretWord`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}fails`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}guessLetters`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}startLetters`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}keyboardLetters`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}keyboardLettersAlt`)??"null"),
            JSON.parse(window.localStorage.getItem(`${storagePrefix}wordList`)??"null"),
        );
    </script>
</head>
<body>
    <div id="box">
        <h1>Hangman</h1>
        <span id="displayWord">loading...</span>
        <span id="timer">--:--</span>
        <span id="guesses">-/-</span>
        <div id="letterButtons">loading...</div>
        <div id="options">
            <input type="button" value="Import" id="importButton" title="open import menu">
            <input type="button" value="New round" id="retryButton" title="start a new round">
            <input type="button" value="Settings" id="settingsButton" title="open settings menu" autofocus>
            <input type="button" value="Export" id="exportButton" title="export current season and settings to file">
        </div>
    </div>
    <dialog id="settingsMenu">
        <h2>Settings</h2>
        <fieldset id="settingsChar">
            <legend title="Letters for guessing (words in the word list must only have these characters)">Alphabet</legend>
            <div id="settingsCharList">Loading...</div>
            <div>
                <input type="text" id="settingsCharInput" placeholder="Add a character" title="Add a new character to the list above (case insensitive)">
                <input type="checkbox" id="settingsCharAlt">
                <label for="settingsCharAlt" role="button" title="Toggle adding alternate characters (not for guessing - will always show)">Alt</label>
            </div>
        </fieldset>
        <fieldset id="settingsWord">
            <legend title="Word list for guessing (chooses a random word from this list) - case insensitive">Word list</legend>
            <div id="settingsWordList">Loading...</div>
            <input type="text" id="settingsWordInput" spellcheck="true" placeholder="Add a word" title="Add a new word to the list above">
        </fieldset>
        <label for="settingsCharRandomUnhide" title="Percentage of letters of the guessing word to randomly unhide (for each round)">
            Randomly unhide
            <input type="number" value="1" min="0" max="99" step="1" id="settingsCharRandomUnhide">
            % of letters
        </label>
        <label for="settingsMaxFails" title="Maximum number of fails per round (-1 → never loose)">
            Max fails
            <input type="number" value="8" min="-1" step="1" id="settingsMaxFails">
        </label>
        <div id="settingsClosing">
            <input type="button" id="settingsReset" value="Reset to default" title="delete saved settings and reload page">
            &verbar;
            <input type="button" id="settingsConfirm" value="OK" title="confirm changes and start a new round">
            <input type="button" id="settingsAbort" value="Abort" title="revert changes and close menu" autofocus>
        </div>
    </dialog>
    <dialog id="importMenu" class="blocked">
        <h2>Import</h2>
        <fieldset>
            <legend title="choose a JSON save file to import data from">import file</legend>
            <input type="file" accept=".json" id="importFile">
        </fieldset>
        <fieldset id="importDataView">
            <legend title="imported data from file">import data</legend>
            <div>
                <fieldset>
                    <legend title="Characters from imported file">Alphabet</legend>
                    <div id="importViewCharList">[Empty]</div>
                </fieldset>
                <fieldset>
                    <legend title="Words from imported file">Word list</legend>
                    <div id="importViewWordList">[Empty]</div>
                </fieldset>
                <span>Randomly unhide <span id="importViewRngUnhide">--</span>% of letters</span>
                <span>Max fails <span id="importViewMaxFails">--</span></span>
                <span>Saved <span id="importViewProgressTime">--:--</span> of progress with <span id="importViewProgressFails">--</span> fail/s</span>
            </div>
        </fieldset>
        <fieldset id="importDataOptions">
            <legend title="select import options">import options</legend>
            <div>
                <label for="importOptionChars" title="import options for the alphabet above (hover over options to get more info)">import characters</label>
                <select id="importOptionChars" title="import options for the alphabet above (hover over options to get more info)" disabled>
                    <option value="replace" title="replaces the current alphabet with the imported alphabet above">override</option>
                    <option value="add" title="adds imported characters to the current alphabet">combine</option>
                    <option value="exclude" title="do not import alphabet" selected>discard</option>
                </select>
                <label for="importOptionWords" title="import options for the word list above (hover over options to get more info)">import words</label>
                <select id="importOptionWords" title="import options for the word list above (hover over options to get more info)" disabled>
                    <option value="replace" title="replaces the current word list with the imported word list above">override</option>
                    <option value="add" title="adds imported words to the current word list">combine</option>
                    <option value="exclude" title="do not import words" selected>discard</option>
                </select>
                <label for="importOptionRngUnhide" title="use the imported rng-unhide value above (checked) or discard it (unchecked)">override unhide value</label>
                <input type="checkbox" id="importOptionRngUnhide" title="use the imported rng-unhide value above (checked) or discard it (unchecked)" disabled>
                <label for="importOptionMaxFails" title="use the imported max-fails value above (checked) or discard it (unchecked)">override max fails value</label>
                <input type="checkbox" id="importOptionMaxFails" title="use the imported max-fails value above (checked) or discard it (unchecked)" disabled>
                <label for="importOptionProgress" title="continue with imported progress (checked) or start a new round (unchecked)">continue progress</label>
                <input type="checkbox" id="importOptionProgress" title="continue with imported progress (checked) or start a new round (unchecked)" disabled>
            </div>
        </fieldset>
        <div id="importClosing">
            <input type="button" id="importConfirm" value="OK" title="confirm options and import data" disabled>
            <input type="button" id="importAbort" value="Abort" title="abort import and close menu" autofocus>
        </div>
    </dialog>
    <dialog id="finMenu">
        <h2>Loading...</h2>
        <fieldset>
            <legend title="Statistics for the last round">Stats</legend>
            <div>Word: <span id="finWord">________</span></div>
            <div>Your guess: <span id="finWordGuess">________</span></div>
            <div>Initial word: <span id="finWordIni">________</span></div>
            <div>Time taken: <span id="finTime">--:--</span></div>
            <div>Failed to guess: <span id="finFails">-</span> of max <span id="finFailsMax">-</span></div>
            <div>All guesses: <span id="finGuesses">________</span></div>
        </fieldset>
        <input type="button" id="finAgain" value="Play again" autofocus title="Start a new round">
    </dialog>
    <dialog id="confirmMenu">
        <h2>Are you sure?</h2>
        <span id="confirmText">________</span>
        <div>
            <input type="button" id="confirmConfirm" value="OK" title="confirm action">
            <input type="button" id="confirmAbort" value="Abort" title="abort action" autofocus>
        </div>
    </dialog>
    <script>
        //~ DOM elements
        /** @type {HTMLSpanElement} the guessing word with `span` for each character (unguessed characters are `█` and use class `hidden` - unhidden characters use class `locked`) *///@ts-ignore element does exist in DOM
        const displayWord=document.getElementById("displayWord");
        /** @type {HTMLSpanElement} timer text element (use {@linkcode formatTimer} for dislaying time) *///@ts-ignore element does exist in DOM
        const timer=document.getElementById("timer");
        /** @type {HTMLSpanElement} text  to show the current and max fails in format `[current fails]/[max fails]` *///@ts-ignore element does exist in DOM
        const guesses=document.getElementById("guesses");
        /** @type {HTMLDivElement} the keyboard with `input[type=button]` for each character (after a character has been choosen the button gets deactivated) *///@ts-ignore element does exist in DOM
        const letterButtons=document.getElementById("letterButtons");
        /** @type {HTMLInputElement} the reset button to start a new round (use {@linkcode retry}) *///@ts-ignore element does exist in DOM
        const retryButton=document.getElementById("retryButton");
        /** @type {HTMLInputElement} button to open the {@linkcode settingsMenu} *///@ts-ignore element does exist in DOM
        const settingsButton=document.getElementById("settingsButton");
        /** @type {HTMLInputElement} button to open the {@linkcode importMenu} *///@ts-ignore element does exist in DOM
        const importButton=document.getElementById("importButton");
        /** @type {HTMLInputElement} button to export current season and settings *///@ts-ignore element does exist in DOM
        const exportButton=document.getElementById("exportButton");

        /** @type {HTMLDialogElement} the import menu element (use this to open or close dialog box) *///@ts-ignore element does exist in DOM
        const importMenu=document.getElementById("importMenu");
        /** @type {HTMLInputElement} the file input element *///@ts-ignore element does exist in DOM
        const importFile=document.getElementById("importFile");
        /** @type {HTMLDivElement} preview of the imported alphabet *///@ts-ignore element does exist in DOM
        const importViewCharList=document.getElementById("importViewCharList");
        /** @type {HTMLDivElement} preview of the imported word list *///@ts-ignore element does exist in DOM
        const importViewWordList=document.getElementById("importViewWordList");
        /** @type {HTMLSpanElement} preview of the imported rng-unhide value *///@ts-ignore element does exist in DOM
        const importViewRngUnhide=document.getElementById("importViewRngUnhide");
        /** @type {HTMLSpanElement} preview of the imported max-fails value *///@ts-ignore element does exist in DOM
        const importViewMaxFails=document.getElementById("importViewMaxFails");
        /** @type {HTMLSpanElement} preview of the imported progress (timer) *///@ts-ignore element does exist in DOM
        const importViewProgressTime=document.getElementById("importViewProgressTime");
        /** @type {HTMLSpanElement} preview of the imported progress (fails / max-fails) *///@ts-ignore element does exist in DOM
        const importViewProgressFails=document.getElementById("importViewProgressFails");
        /** @type {HTMLSelectElement} inport options (replace|add|exclude) for alphabet *///@ts-ignore element does exist in DOM
        const importOptionChars=document.getElementById("importOptionChars");
        /** @type {HTMLSelectElement} import options (replace|add|exclude) for word list *///@ts-ignore element does exist in DOM
        const importOptionWords=document.getElementById("importOptionWords");
        /** @type {HTMLInputElement} import option (checkbox - override?) for rng-unhide value *///@ts-ignore element does exist in DOM
        const importOptionRngUnhide=document.getElementById("importOptionRngUnhide");
        /** @type {HTMLInputElement} import option (checkbox - override?) for max-fails value *///@ts-ignore element does exist in DOM
        const importOptionMaxFails=document.getElementById("importOptionMaxFails");
        /** @type {HTMLInputElement} import option (checkbox - continue?) for saved progress *///@ts-ignore element does exist in DOM
        const importOptionProgress=document.getElementById("importOptionProgress");
        /** @type {HTMLInputElement} confirm button for {@linkcode importMenu} *///@ts-ignore element does exist in DOM
        const importConfirm=document.getElementById("importConfirm");
        /** @type {HTMLInputElement} abort button for {@linkcode importMenu} *///@ts-ignore element does exist in DOM
        const importAbort=document.getElementById("importAbort");

        /** @type {HTMLDialogElement} the settings menu element (use this to open or close dialog box) *///@ts-ignore element does exist in DOM
        const settingsMenu=document.getElementById("settingsMenu");
        /** @type {HTMLDivElement} the character list (list of `input[type=button]` and `input[type=button].unhide` elements for each character) *///@ts-ignore element does exist in DOM
        const settingsCharList=document.getElementById("settingsCharList");
        /** @type {HTMLInputElement} text input for adding characters to {@linkcode settingsCharList} *///@ts-ignore element does exist in DOM
        const settingsCharInput=document.getElementById("settingsCharInput");
        /** @type {HTMLInputElement} toggle (checkbox) for adding alternate characters (or not) from {@linkcode settingsCharInput} to {@linkcode settingsCharList} *///@ts-ignore element does exist in DOM
        const settingsCharAlt=document.getElementById("settingsCharAlt");
        /** @type {HTMLDivElement} the word list (list of `span` and `input[type=button]` within a `div` for each word) *///@ts-ignore element does exist in DOM
        const settingsWordList=document.getElementById("settingsWordList");
        /** @type {HTMLInputElement} text input for adding words to {@linkcode settingsWordList} *///@ts-ignore element does exist in DOM
        const settingsWordInput=document.getElementById("settingsWordInput");
        /** @type {HTMLInputElement} number input for getting the "random unhide letters by percentage" value *///@ts-ignore element does exist in DOM
        const settingsCharRandomUnhide=document.getElementById("settingsCharRandomUnhide");
        /** @type {HTMLInputElement} number input for getting the "max failed attemps" value *///@ts-ignore element does exist in DOM
        const settingsMaxFails=document.getElementById("settingsMaxFails");
        /** @type {HTMLInputElement} button to delete stored settings and reload the page *///@ts-ignore element does exist in DOM
        const settingsReset=document.getElementById("settingsReset");
        /** @type {HTMLInputElement} button to confirm set settings and close {@linkcode settingsMenu} *///@ts-ignore element does exist in DOM
        const settingsConfirm=document.getElementById("settingsConfirm");
        /** @type {HTMLInputElement} button to abort and revert set settings and close {@linkcode settingsMenu} *///@ts-ignore element does exist in DOM
        const settingsAbort=document.getElementById("settingsAbort");

        /** @type {HTMLDialogElement} the fin menu element (use this to open or close dialog box) *///@ts-ignore element does exist in DOM
        const finMenu=document.getElementById("finMenu");
        /** @type {HTMLHeadingElement} the h2 heading in {@linkcode finMenu} *///@ts-ignore element does exist in DOM
        const finMenuHeading=finMenu.querySelector("h2");
        /** @type {HTMLSpanElement} the word guessed {@linkcode displayWord} fully uncovered *///@ts-ignore element does exist in DOM
        const finWord=document.getElementById("finWord");
        /** @type {HTMLSpanElement} the word guessed {@linkcode displayWord} *///@ts-ignore element does exist in DOM
        const finWordGuess=document.getElementById("finWordGuess");
        /** @type {HTMLSpanElement} the word guessed {@linkcode displayWord} in its original state at the start of the round *///@ts-ignore element does exist in DOM
        const finWordIni=document.getElementById("finWordIni");
        /** @type {HTMLSpanElement} the time it took to guess the word (use {@linkcode formatTimer}) *///@ts-ignore element does exist in DOM
        const finTime=document.getElementById("finTime");
        /** @type {HTMLSpanElement} the total fails of this round *///@ts-ignore element does exist in DOM
        const finFails=document.getElementById("finFails");
        /** @type {HTMLSpanElement} all guesses of this round *///@ts-ignore element does exist in DOM
        const finGuesses=document.getElementById("finGuesses");
        /** @type {HTMLSpanElement} the max fails allowed for this round *///@ts-ignore element does exist in DOM
        const finFailsMax=document.getElementById("finFailsMax");
        /** @type {HTMLInputElement} button to close the {@linkcode finMenu} and start a new round *///@ts-ignore element does exist in DOM
        const finAgain=document.getElementById("finAgain");

        /** @type {HTMLDialogElement} the confirm menu element (use this to open or close dialog box) *///@ts-ignore element does exist in DOM
        const confirmMenu=document.getElementById("confirmMenu");
        /** @type {HTMLSpanElement} the text to confirm in the {@linkcode confirmMenu} *///@ts-ignore element does exist in DOM
        const confirmText=document.getElementById("confirmText");
        /** @type {HTMLInputElement} button to confirm action and close {@linkcode confirmMenu} *///@ts-ignore element does exist in DOM
        const confirmConfirm=document.getElementById("confirmConfirm");
        /** @type {HTMLInputElement} button to abort action and close {@linkcode confirmMenu} *///@ts-ignore element does exist in DOM
        const confirmAbort=document.getElementById("confirmAbort");

        //~ confirm dialog box
        const confirmDialog=Object.seal(new class ConfirmDialog{
            /** @type {((aborted:boolean)=>Promise<void>|void)|null} [Private] Current callback when dialog is closed (can be async) */
            static _callback_=null;
            /** @type {HTMLDialogElement} [Private] The dialog HTML element to open/close */
            static _dialog_;
            /** @type {HTMLSpanElement} [Private] The text HMTL element of {@linkcode _dialog_} to show a confirm message */
            static _title_;
            /** @type {HTMLInputElement} [Private] The confirm button HMTL element of {@linkcode _dialog_} */
            static _confirm_;
            /** @type {HTMLInputElement} [Private] The abort button HMTL element of {@linkcode _dialog_} */
            static _abort_;
            /** @type {boolean} [Private] If a dialog is currently still pending (can't open another one) */
            static _running_=false;
            /** @type {boolean} If a dialog is currently still pending (can't open another one) */
            get Running(){return ConfirmDialog._running_;}
            /**
             * ## Initializes {@linkcode ConfirmDialog} object
             * @param {HTMLDialogElement} dialog - the confirm HMTL dialog element
             * @param {HTMLSpanElement} text - the HTML text element of {@linkcode dialog} to show a confirm message
             * @param {HTMLInputElement} confirm - the confirm button of {@linkcode dialog}
             * @param {HTMLInputElement} abort - the abort button of {@linkcode dialog}
             */
            constructor(dialog,text,confirm,abort){
                ConfirmDialog._title_=text;
                ConfirmDialog._dialog_=dialog;
                ConfirmDialog._confirm_=confirm;
                ConfirmDialog._abort_=abort;
                ConfirmDialog._dialog_.addEventListener("cancel",async ev=>{"use strict";ev.preventDefault();ConfirmDialog._abort_.click();},{passive:false});
                ConfirmDialog._confirm_.addEventListener("click",async()=>ConfirmDialog._exit_(false),{passive:true});
                ConfirmDialog._abort_.addEventListener("click",async()=>ConfirmDialog._exit_(true),{passive:true});
            }
            /**
             * ## [Private, async] Called by an event listener when the dialog was closed
             * @param {boolean} aborted - if the dialog was aborted (`true`) or confirmed (`false`)
             */
            static async _exit_(aborted){
                "use strict";
                ConfirmDialog._dialog_.close();
                const call=ConfirmDialog._callback_;
                ConfirmDialog._callback_=null;
                ConfirmDialog._running_=false;
                await call?.(aborted);
            };
            /**
             * ## Shows a dialog that displays the {@linkcode action} to confirm
             * check if another dialog is still pending via {@linkcode Running}
             * @param {string} action - the action to confirm
             * @param {(aborted:boolean)=>Promise<void>|void} callback - a (strict, passive, optionally async) function, called when the {@linkcode action} was confirmed (param `false`) or aborted (param `true`)
             * @throws {Error} if another dialog is still pending
             */
            Setup(action,callback){
                if(ConfirmDialog._running_)throw new Error("[ConfirmDialog:setup] another dialog is still pending");
                ConfirmDialog._title_.textContent=action;
                ConfirmDialog._callback_=callback;
                ConfirmDialog._dialog_.showModal();
            }
            /**
             * ## Removes event listeners from `dialog`, `confirm`, and `abort` HTML elements (only call before deleting object)
             * check if a dialog is still pending via {@linkcode Running}
             * @param {boolean} [force] - [Optional] if `true` forces a pending dialog to abort
             * @throws {TypeError} if {@linkcode force} is set, but not a boolean
             * @throws {Error} if a dialog is still pending
             */
            static async RemoveListeners(force){
                if(force!=null&&typeof force!=="boolean")throw new TypeError("[ConfirmDialog:RemoveListeners] force is not a boolean");
                if(force==null||!force){
                    if(ConfirmDialog._running_)throw new Error("[ConfirmDialog:setup] a dialog is still pending");
                }else await ConfirmDialog._exit_(true);
                ConfirmDialog._dialog_.removeEventListener("cancel",async ev=>{"use strict";ev.preventDefault();ConfirmDialog._abort_.click();});
                ConfirmDialog._confirm_.removeEventListener("click",async()=>ConfirmDialog._exit_(false));
                ConfirmDialog._abort_.removeEventListener("click",async()=>ConfirmDialog._exit_(true));
            }
        }(confirmMenu,confirmText,confirmConfirm,confirmAbort));

        //~ game logic (after DOM loaded and elements exist as variables)
        /**
         * ## Ends the rund by showing the {@linkcode finMenu}
         * @param {boolean} win - `true` if this round was won and `false` if lost
         */
        const endRound=win=>{
            finTime.textContent=formatTimer(Date.now()-startTime);
            finMenuHeading.textContent=win?"Congratulations":"Game over";
            finWord.textContent=secretWord;
            finWordGuess.replaceChildren(...Array.from(secretWord.matchAll(unicodeRegExp),(match,i)=>{
                "use strict";
                const upper=match[0].toLocaleUpperCase(),
                    isLocked=keyboardLettersAlt.has(upper)||startLetters.has(upper),
                    txt=document.createElement("span");
                if(!isLocked&&guessLetters.has(upper)){
                    txt.textContent=match[0];
                    return txt;
                }
                txt.textContent=isLocked?match[0]:"█";
                txt.classList.add(isLocked?"locked":"hidden");
                return txt;
            }));
            finWordIni.replaceChildren(...Array.from(secretWord.matchAll(unicodeRegExp),match=>{
                "use strict";
                const upper=match[0].toLocaleUpperCase(),
                    isLocked=keyboardLettersAlt.has(upper)||startLetters.has(upper),
                    txt=document.createElement("span");
                txt.textContent=isLocked?match[0]:"█";
                txt.classList.add(isLocked?"locked":"hidden");
                return txt;
            }));
            finFails.textContent=fails.toString();
            finFailsMax.textContent=maxFails===-1?"∞":maxFails.toString();
            finGuesses.replaceChildren(...Array.from(guessLetters,v=>{
                "use strict";
                const txt=document.createElement("span");
                txt.textContent=v;
                if([...secretWord.toLocaleUpperCase().matchAll(unicodeRegExp)].every(m=>m[0]!==v))txt.classList.add("fail");
                return txt;
            }));
            finMenu.showModal();
        };
        /**
         * ## function callback when clicking on a letter for guessing
         * @param {string} letter - the letter (value) that was clicked on
         */
        const letterClick=letter=>{
            "use strict";
            guessLetters.add(letter);
            const guessIndices=guess(letter);
            if(guessIndices.size===0){
                if(++fails>maxFails&&maxFails!==-1)endRound(false);
                updateFails();
                updateLocalStorage();
                return;
            }
            if([...secretWord.toLocaleUpperCase().matchAll(unicodeRegExp)].every(m=>
                guessLetters.has(m[0])
                ||startLetters.has(m[0])
                ||keyboardLettersAlt.has(m[0])
            ))endRound(true);
            updateWord();
            updateLocalStorage();
        }
        /** ## updates {@linkcode displayWord} with current settings ({@linkcode guessWord}) */
        const updateWord=()=>{
            "use strict";
            displayWord.replaceChildren(...Array.from(secretWord.matchAll(unicodeRegExp),(match,i)=>{
                "use strict";
                const txt=document.createElement("span"),
                    upper=match[0].toLocaleUpperCase();
                if(guessLetters.has(upper))txt.textContent=match[0];
                else if(keyboardLettersAlt.has(upper)||startLetters.has(upper)){
                    txt.textContent=match[0];
                    txt.classList.add("locked");
                }else{
                    txt.textContent="█";
                    txt.classList.add("hidden");
                }
                return txt;
            }));
        };
        /** ## updates the {@linkcode guesses} value */
        const updateFails=()=>{
            "use strict";
            if(maxFails===-1){
                guesses.textContent=`${fails}/∞`;
                return;
            }
            guesses.textContent=`${fails}/${maxFails}`;
            if(fails/maxFails<.3)guesses.style.color="";
            else if(fails/maxFails<.5)guesses.style.color="#F90";
            else guesses.style.color="#F22";
        };
        /** ## updates the keyboard with current settings ({@linkcode keyboardLetters} and {@linkcode startLetters}) */
        const updateKeyboard=()=>{
            "use strict";
            letterButtons.replaceChildren(...Array.from(keyboardLetters).map(v=>{
                "use strict";
                const letter=document.createElement("input");
                letter.type="button";
                letter.value=v;
                if(startLetters.has(v)||guessLetters.has(v))letter.disabled=true;
                else letter.addEventListener("click",()=>{
                    "use strict";
                    letter.disabled=true;
                    let focus=letter.nextElementSibling;
                    while(
                        focus!=null
                        &&(focus instanceof HTMLInputElement)
                        &&focus.type==="button"
                        &&focus.disabled
                        &&keyboardLetters.has(focus.value)
                    )focus=focus.nextElementSibling;
                    if(
                        (focus instanceof HTMLInputElement)
                        &&focus.type==="button"
                        &&!focus.disabled
                        &&keyboardLetters.has(focus.value)
                    )focus.focus();
                    else{
                        focus=letter.previousElementSibling;
                        while(
                            focus!=null
                            &&(focus instanceof HTMLInputElement)
                            &&focus.type==="button"
                            &&focus.disabled
                            &&keyboardLetters.has(focus.value)
                        )focus=focus.previousElementSibling;
                        if(
                            (focus instanceof HTMLInputElement)
                            &&focus.type==="button"
                            &&!focus.disabled
                            &&keyboardLetters.has(focus.value)
                        )focus.focus();
                        else retryButton.focus();
                    }
                    letterClick(letter.value);
                },{passive:true,once:true});
                return letter;
            }));
        };
        /**
         * ## removes all words from {@linkcode settingsWordList} and {@linkcode confWordList} that contain {@linkcode char}
         * @param {string} char - a letter from the alphabet
         */
        const removeWordsWithChar=char=>{
            "use strict";
            for(let i=settingsWordList.childElementCount-1;i>=0;i--){
                const container=settingsWordList.childNodes.item(i);
                if(container?.firstChild?.textContent?.toLocaleUpperCase()?.includes(char)??false)container.remove();
            }
            for(const word of confWordList)
                if(word.toLocaleUpperCase().includes(char))confWordList.delete(word);
        }
        /**
         * ## adds {@linkcode char} to {@linkcode confKeyboardLetters} and as button to {@linkcode settingsCharList} (incl. event listener for removal)
         * @param {string} char - a single letter for the alphabet
         * @param {boolean} alt - if `true` uses {@linkcode confKeyboardLettersAlt} instead and adds class "unhide" to button
         */
        const settingsAddChar=(char,alt)=>{
            "use strict";
            const letter=document.createElement("input");
            letter.type="button";
            letter.value=char;
            letter.title="Click to remove this character and all words containing it";
            settingsCharList.insertBefore(letter,settingsCharList.firstChild);
            if(alt){
                letter.title=`(This character will always show) ${letter.title}`;
                letter.classList.add("unhide");
                confKeyboardLettersAlt.add(char);
                letter.addEventListener("click",()=>{
                    "use strict";
                    confKeyboardLettersAlt.delete(char);
                    removeWordsWithChar(char);
                    let focus=letter.nextElementSibling;
                    if(
                        (focus instanceof HTMLInputElement)
                        &&focus.type==="button"
                        &&(confKeyboardLetters.has(focus.value)||confKeyboardLettersAlt.has(focus.value))
                    )focus.focus();
                    else{
                        focus=letter.previousElementSibling;
                        if(
                            (focus instanceof HTMLInputElement)
                            &&focus.type==="button"
                            &&(confKeyboardLetters.has(focus.value)||confKeyboardLettersAlt.has(focus.value))
                        )focus.focus();
                        else settingsCharInput.focus();
                    }
                    letter.remove();
                },{passive:true,once:true});
            }else{
                confKeyboardLetters.add(char);
                letter.addEventListener("click",()=>{
                    "use strict";
                    confKeyboardLetters.delete(char);
                    removeWordsWithChar(char);
                    let focus=letter.nextElementSibling;
                    if(
                        (focus instanceof HTMLInputElement)
                        &&focus.type==="button"
                        &&(confKeyboardLetters.has(focus.value)||confKeyboardLettersAlt.has(focus.value))
                    )focus.focus();
                    else{
                        focus=letter.previousElementSibling;
                        if(
                            (focus instanceof HTMLInputElement)
                            &&focus.type==="button"
                            &&(confKeyboardLetters.has(focus.value)||confKeyboardLettersAlt.has(focus.value))
                        )focus.focus();
                        else settingsCharInput.focus();
                    }
                    letter.remove();
                },{passive:true,once:true});
            }
        }
        /**
         * ## switches a character from alternate to normal (and vice versa)
         * @param {string} char - the character
         */
        const settingsSwitchChar=char=>{
            "use strict";
            /** @type {[HTMLInputElement|null,HTMLInputElement|null]} [alt letter, letter] */
            const letters=[null,null];
            for(const letter of settingsCharList.children)
                if(letter instanceof HTMLInputElement&&letter.value===char){
                    if(letter.classList.contains("unhide"))letters[0]=letter;
                    else letters[1]=letter;
                    break;
                }
            if(letters[0]!=null){
                letters[0].remove();
                confKeyboardLettersAlt.delete(char);
                settingsAddChar(char,false);
            }else if(letters[1]!=null){
                letters[1].remove();
                confKeyboardLetters.delete(char);
                settingsAddChar(char,true);
            }
        }
        /**
         * ## adds {@linkcode word} to {@linkcode confWordList} and {@linkcode settingsWordList} (with a button to remove)
         * @param {string} word - a word for the guessing words list
         */
        const settingsAddWord=word=>{
            "use strict";
            confWordList.add(word);
            const container=document.createElement("div"),
                txt=document.createElement("span"),
                btn=document.createElement("input");
            txt.textContent=word;
            btn.type="button";
            btn.value="x";
            btn.title="Click to remove this word from the list";
            container.append(txt,btn);
            settingsWordList.insertBefore(container,settingsWordList.firstChild);
            btn.addEventListener("click",()=>{
                "use strict";
                confWordList.delete(word);
                let focus=container.nextElementSibling;
                if(
                    (focus instanceof HTMLDivElement)
                    &&((focus=focus.lastElementChild) instanceof HTMLInputElement)
                    &&focus.value==="x"
                )focus.focus();
                else{
                    focus=container.previousElementSibling;
                    if(
                        (focus instanceof HTMLDivElement)
                        &&((focus=focus.lastElementChild) instanceof HTMLInputElement)
                        &&focus.value==="x"
                    )focus.focus();
                    else settingsWordInput.focus();
                }
                container.remove();
            },{passive:true,once:true});
        }
        /**
         * ## change capitalization of an existing word in {@linkcode confWordList}
         * @param {string} oldWord - the existing word
         * @param {string} newWord - the newly capitalized word
         */
        const settingsCasingWord=(oldWord,newWord)=>{
            for(const container of settingsWordList.children)
                if(container.firstChild?.textContent===oldWord){
                    container.remove();
                    confWordList.delete(oldWord);
                    settingsAddWord(newWord);
                }
        }
        //~ add all event listeners
        let timerInterval=setInterval(()=>{
            "use strict";
            timer.textContent=formatTimer(Date.now()-startTime);
            window.localStorage.setItem(`${storagePrefix}time`,JSON.stringify(Date.now()-startTime));
        },300);
        document.body.addEventListener("mousedown",()=>document.getSelection()?.empty(),{passive:true});
        document.body.addEventListener("keydown",ev=>{
            if(ev.repeat||settingsMenu.open||finMenu.open||confirmMenu.open)return;
            const key=ev.key.toLocaleUpperCase();
            if(!keyboardLetters.has(key))return;
            ev.preventDefault();
            for(const letter of letterButtons.children)
                if(letter instanceof HTMLInputElement&&letter.value===key){
                    letter.click();
                    break;
                }
        },{passive:false});

        retryButton.addEventListener("click",()=>{
            "use strict";
            const confirmFnc=aborted=>{
                "use strict";
                if(aborted)return;
                retry();
                updateKeyboard();
                updateWord();
                updateFails();
                updateLocalStorage();
            };
            if(Date.now()-startTime>20000){
                if(confirmDialog.Running)confirmFnc(true);
                else confirmDialog.Setup(`Abandon ${formatTimer(Date.now()-startTime)} of progress and start a new round?`,confirmFnc);
            }else confirmFnc(false);
        },{passive:true});
        settingsButton.addEventListener("click",()=>{
            "use strict";
            settingsCharList.replaceChildren();
            confKeyboardLetters.clear();
            for(const letter of keyboardLetters)settingsAddChar(letter,false);
            confKeyboardLettersAlt.clear();
            for(const letter of keyboardLettersAlt)settingsAddChar(letter,true);
            settingsWordList.replaceChildren();
            confWordList.clear();
            for(const word of wordList)settingsAddWord(word);
            settingsCharRandomUnhide.value=rngUnhide.toString();
            settingsMaxFails.value=maxFails.toString();
            settingsMenu.showModal();
        },{passive:true});
        exportButton.addEventListener("click",()=>saveToFile(),{passive:true});

        /**
         * ## resets values and variables of the import menu
         * @param {boolean} removeFile - if `true` also removes any file from {@linkcode importFile}
         */
        const importMenuReset=removeFile=>{
            "use strict";
            importMenu.classList.add("blocked");
            if(removeFile)importFile.value="";
            importViewCharList.replaceChildren("[Empty]");
            importViewWordList.replaceChildren("[Empty]");
            importViewRngUnhide.textContent="--";
            importViewMaxFails.textContent="--";
            importViewProgressTime.textContent="--:--";
            importViewProgressFails.textContent="--";
            importGuessLetters.clear();
            importStartLetters.clear();
            importKeyboardLetters.clear();
            importKeyboardLettersAlt.clear();
            importWordList.clear();
            importMaxFails=NaN;
            importFails=NaN;
            importRngUnhide=NaN;
            importTime=NaN;
            importSecretWord="";
            importOptionChars.value="exclude";
            importOptionChars.disabled=true;
            importOptionWords.value="exclude";
            importOptionWords.disabled=true;
            importOptionRngUnhide.checked=false;
            importOptionRngUnhide.disabled=true;
            importOptionMaxFails.checked=false;
            importOptionMaxFails.disabled=true;
            importOptionProgress.checked=false;
            importOptionProgress.disabled=true;
            importConfirm.disabled=true;
        };
        importButton.addEventListener("click",()=>{
            "use strict";
            importMenu.showModal();
        },{passive:true});
        importAbort.addEventListener("click",()=>{
            "use strict";
            importMenu.close();
            importMenuReset(true);
        },{passive:true});
        importMenu.addEventListener("cancel",ev=>{
            "use strict";
            ev.preventDefault();
            importAbort.click();
        },{passive:false});
        importConfirm.addEventListener("click",()=>{
            "use strict";
            switch(importOptionChars.value){
                case"replace":
                    keyboardLetters.clear();
                    keyboardLettersAlt.clear();
                    //! fall through
                case"add":
                    for(const char of importKeyboardLetters)keyboardLetters.add(char);
                    for(const char of importKeyboardLettersAlt)keyboardLettersAlt.add(char);
                break;
                case"exclude":break;
            }
            switch(importOptionWords.value){
                case"replace":
                    wordList.clear();
                    //! fall through
                case"add":
                    for(const word of importWordList)wordList.add(word);
                break;
                case"exclude":break;
            }
            if(importOptionRngUnhide.checked)rngUnhide=importRngUnhide;
            if(importOptionMaxFails.checked)maxFails=importMaxFails;
            if(importOptionProgress.checked){
                fails=importFails;
                startTime=Date.now()-importTime;
                secretWord=importSecretWord;
                startLetters.clear();
                for(const char of importStartLetters)startLetters.add(char);
                guessLetters.clear();
                for(const char of importGuessLetters)guessLetters.add(char);
            }
            importMenu.close();
            importMenuReset(true);
            updateKeyboard();
            updateWord();
            updateFails();
            updateLocalStorage();
        },{passive:true});
        importFile.addEventListener("change",async()=>{
            "use strict";
            importMenuReset(false);
            if(importFile.files?.length===1){
                if(await loadFromFile(importFile.files[0])){
                    if(importKeyboardLetters.size+importKeyboardLettersAlt.size>0){
                        importViewCharList.replaceChildren();
                        for(const char of importKeyboardLettersAlt){
                            const key=document.createElement("span");
                            key.textContent=char;
                            key.classList.add("unhide");
                            importViewCharList.append(key);
                        }
                        for(const char of importKeyboardLetters){
                            const key=document.createElement("span");
                            key.textContent=char;
                            importViewCharList.append(key);
                        }
                        importOptionChars.value="replace";
                        importOptionChars.disabled=false;
                    }
                    if(importWordList.size>0){
                        importViewWordList.replaceChildren();
                        for(const word of importWordList){
                            const container=document.createElement("div"),
                            txt=document.createElement("span");
                            txt.textContent=word;
                            container.append(txt);
                            importViewWordList.append(container);
                        }
                        importOptionWords.value="replace";
                        importOptionWords.disabled=false;
                    }
                    if(!Number.isNaN(importRngUnhide)){
                        importViewRngUnhide.textContent=importRngUnhide.toString();
                        importOptionRngUnhide.checked=true;
                        importOptionRngUnhide.disabled=false;
                    }
                    if(!Number.isNaN(importMaxFails)){
                        importViewMaxFails.textContent=importMaxFails===-1?"∞":importMaxFails.toString();
                        importOptionMaxFails.checked=true;
                        importOptionMaxFails.disabled=false;
                    }
                    if(importSecretWord!==""){
                        importViewProgressTime.textContent=formatTimer(importTime);
                        importViewProgressFails.textContent=importFails.toString();
                        importOptionProgress.checked=true;
                        importOptionProgress.disabled=false;
                    }
                    importConfirm.disabled=false;
                    importMenu.classList.remove("blocked");
                }
            }
        },{passive:true});
        importOptionChars.addEventListener("change",()=>{
            "use strict";
            if(importWordList.size>0){
                if(importOptionChars.value==="exclude"){
                    importOptionWords.disabled=true;
                    importOptionWords.value="exclude";
                }else importOptionWords.disabled=false;
            }
            if(importSecretWord==="")return;
            if(importOptionChars.value==="exclude"||importOptionWords.value==="exclude"||!importOptionMaxFails.checked){
                importOptionProgress.disabled=true;
                importOptionProgress.checked=false;
            }else importOptionProgress.disabled=false;
        },{passive:true});
        importOptionWords.addEventListener("change",()=>{
            "use strict";
            if(importSecretWord==="")return;
            if(importOptionChars.value==="exclude"||importOptionWords.value==="exclude"||!importOptionMaxFails.checked){
                importOptionProgress.disabled=true;
                importOptionProgress.checked=false;
            }else importOptionProgress.disabled=false;
        },{passive:true});
        importOptionMaxFails.addEventListener("change",()=>{
            "use strict";
            if(importSecretWord==="")return;
            if(importOptionChars.value==="exclude"||importOptionWords.value==="exclude"||!importOptionMaxFails.checked){
                importOptionProgress.disabled=true;
                importOptionProgress.checked=false;
            }else importOptionProgress.disabled=false;
        },{passive:true});

        settingsMenu.addEventListener("cancel",ev=>{
            ev.preventDefault();
            settingsAbort.click();
        },{passive:false});
        settingsCharInput.addEventListener("change",()=>{
            "use strict";
            for(const[char]of settingsCharInput.value.toLocaleUpperCase().matchAll(unicodeRegExp))
                if(settingsCharAlt.checked){
                    if(confKeyboardLettersAlt.has(char))continue;
                    if(confKeyboardLetters.has(char))settingsSwitchChar(char);
                    else settingsAddChar(char,true);
                }else{
                    if(confKeyboardLetters.has(char))continue;
                    if(confKeyboardLettersAlt.has(char))settingsSwitchChar(char);
                    else settingsAddChar(char,false);
                }
            settingsCharInput.value="";
        },{passive:true});
        settingsWordInput.addEventListener("change",()=>{
            "use strict";
            if(confWordList.has(settingsWordInput.value))return;
            const upper=settingsWordInput.value.toLocaleUpperCase();
            for(const confWord of confWordList)
                if(confWord.toLocaleUpperCase()===upper){
                    settingsCasingWord(confWord,settingsWordInput.value);
                    return;
                }
            for(const[char]of upper.matchAll(unicodeRegExp)){
                if(confKeyboardLetters.has(char))continue;
                if(confKeyboardLettersAlt.has(char))continue;
                settingsAddChar(char,settingsCharAlt.checked);
            }
            settingsAddWord(settingsWordInput.value);
            settingsWordInput.value="";
        },{passive:true});
        settingsCharRandomUnhide.addEventListener("input",()=>{
            "use strict";
            settingsCharRandomUnhide.setCustomValidity("");
            const num=Number(settingsCharRandomUnhide.value);
            if(settingsCharRandomUnhide.value===""||Number.isNaN(num)||num<0||num>99)settingsCharRandomUnhide.setCustomValidity("Must be a number from 0 to 99");
        },{passive:true});
        settingsMaxFails.addEventListener("input",()=>{
            "use strict";
            settingsMaxFails.setCustomValidity("");
            const num=Number(settingsMaxFails.value);
            if(settingsMaxFails.value===""||Number.isNaN(num)||num<-1||!Number.isSafeInteger(num))settingsMaxFails.setCustomValidity("Must be an integer larger or equal to -1");
        },{passive:true});
        settingsAbort.addEventListener("click",()=>{
            "use strict";
            settingsCharList.replaceChildren();
            confKeyboardLetters.clear();
            for(const letter of keyboardLetters)settingsAddChar(letter,false);
            confKeyboardLettersAlt.clear();
            for(const letter of keyboardLettersAlt)settingsAddChar(letter,true);
            confWordList.clear();
            for(const word of wordList)settingsAddWord(word);
            settingsCharRandomUnhide.value=rngUnhide.toString();
            settingsMaxFails.value=maxFails.toString();
            settingsMenu.close();
        },{passive:true});
        settingsConfirm.addEventListener("click",()=>{
            "use strict";
            if(!settingsCharRandomUnhide.reportValidity())return;
            if(!settingsMaxFails.reportValidity())return;
            keyboardLetters.clear();
            for(const letter of confKeyboardLetters)keyboardLetters.add(letter);
            keyboardLettersAlt.clear();
            for(const letter of confKeyboardLettersAlt)keyboardLettersAlt.add(letter);
            wordList.clear();
            for(const word of confWordList)wordList.add(word);
            rngUnhide=Number(settingsCharRandomUnhide.value);
            maxFails=Number(settingsMaxFails.value);
            settingsMenu.close();
            retry();
            updateKeyboard();
            updateWord();
            updateFails();
            updateLocalStorage();
        },{passive:true});
        settingsReset.addEventListener("click",()=>{
            "use strict";
            if(!confirmDialog.Running)confirmDialog.Setup("Delete all settings and reload the page?",aborted=>{
                "use strict";
                if(aborted)return;
                clearLocalStorage();
                window.location.reload();
            });
        },{passive:true});

        finMenu.addEventListener("cancel",ev=>{
            ev.preventDefault();
            finAgain.click();
        },{passive:false});
        finAgain.addEventListener("click",()=>{
            "use strict";
            finMenu.close();
            retry();
            updateKeyboard();
            updateWord();
            updateFails();
            updateLocalStorage();
            let focus=letterButtons.firstElementChild;
            while(
                focus!=null
                &&(focus instanceof HTMLInputElement)
                &&focus.type==="button"
                &&focus.disabled
                &&keyboardLetters.has(focus.value)
            )focus=focus.nextElementSibling;
            if(
                (focus instanceof HTMLInputElement)
                &&focus.type==="button"
                &&!focus.disabled
                &&keyboardLetters.has(focus.value)
            )focus.focus();
            else retryButton.focus();
        },{passive:true});

        //~ start the game
        if(Number.isNaN(startTime))retry();
        updateKeyboard();
        updateWord();
        updateFails();
        updateLocalStorage();
        (()=>{//~ focus the first available letter or the retry button
            "use strict";
            let focus=letterButtons.firstElementChild;
            while(
                focus!=null
                &&(focus instanceof HTMLInputElement)
                &&focus.type==="button"
                &&focus.disabled
                &&keyboardLetters.has(focus.value)
            )focus=focus.nextElementSibling;
            if(
                (focus instanceof HTMLInputElement)
                &&focus.type==="button"
                &&!focus.disabled
                &&keyboardLetters.has(focus.value)
            )focus.focus();
            else retryButton.focus();
        })();
    </script>
</body>
</html>
